[
  {
    "objectID": "posts/ZAT_profile_map/ZAT_profile_map.html",
    "href": "posts/ZAT_profile_map/ZAT_profile_map.html",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "",
    "text": "After using finite mixture modeling to cluster the neighborhoods (ZATs) across all the ZAT-level indicators on road infrastructures, we’ll visualize the resulting neighborhood profiles on maps.\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(tmap)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(leaflet)\nlibrary(glue)"
  },
  {
    "objectID": "posts/ZAT_profile_map/ZAT_profile_map.html#data-preparation",
    "href": "posts/ZAT_profile_map/ZAT_profile_map.html#data-preparation",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Data preparation",
    "text": "Data preparation\nAs mentioned in the previous post, all ZAT-level indicators were categorized into two domains, street design and transportation, and the neighborhood profiles are generated for each ZAT unit from the Gaussian mixture model-based clustering across the variables in each domain, as well as in both domains together. From the modeling results, we could extract the domain-specific and overall cluster information of all ZATs with clusters(), and join the data with the ZAT-level shapefiles in ZAT folder to get the geometry.\n\n\nCode\nzat_cluster &lt;- zat_std2 %&gt;% \n  select(ZAT) %&gt;% \n  mutate(all = clusters(all_mix_c),\n         street = clusters(st_mix_c),\n         transp = clusters(tp_mix_c)) %&gt;% \n  left_join(zat, by = \"ZAT\") %&gt;% \n  select(ZAT, all, street, transp, geometry) %&gt;% \n  st_as_sf()"
  },
  {
    "objectID": "posts/ZAT_profile_map/ZAT_profile_map.html#mapping-the-profiles",
    "href": "posts/ZAT_profile_map/ZAT_profile_map.html#mapping-the-profiles",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Mapping the profiles",
    "text": "Mapping the profiles\nTo spatially visualize the neighborhood profiles, we’ll create 3 maps to plot the cluster assignment of each ZAT unit for street design domain, transportation domain and both domains together.\n\n\nCode\nstreet &lt;- zat_cluster %&gt;%\n  select(ZAT, geometry, street) %&gt;%\n  drop_na() %&gt;%\n  #using NAD83 in tmap\n  tm_shape(projection = sf::st_crs(26915))+\n  tm_polygons(\"street\",\n    palette = \"YlGn\",\n    style = \"cat\",\n    title = \"cluster\")+\n  tm_layout(panel.show = TRUE,\n    panel.labels = \"Street Design Profiles\",\n    panel.label.fontface = \"bold\",\n    title.position = c(\"left\", \"TOP\"),\n    legend.position = c(\"RIGHT\", \"bottom\"),\n    legend.title.size = 0.9,\n    legend.width = 2)\n\ntransp &lt;- zat_cluster %&gt;%\n  select(ZAT, geometry, transp) %&gt;%\n  drop_na() %&gt;%\n  #using NAD83 in tmap\n  tm_shape(projection = sf::st_crs(26915))+\n  tm_polygons(\"transp\",\n    palette = \"YlGn\", \n    style = \"cat\",\n    title = \"cluster\")+\n  tm_layout(panel.show = TRUE,\n    panel.labels = \"Transportation Profiles\",\n    panel.label.fontface = \"bold\",\n    title.position = c(\"left\", \"TOP\"),\n    legend.position = c(\"RIGHT\", \"bottom\"),\n    legend.title.size = 0.9,\n    legend.width = 2)\n\nall_ind &lt;- zat_cluster %&gt;%\n  select(ZAT, geometry, all) %&gt;%\n  drop_na() %&gt;%\n  #using NAD83 in tmap\n  tm_shape(projection = sf::st_crs(26915))+\n  tm_polygons(\"all\",\n    palette = \"YlGn\", \n    style = \"cat\",\n    title = \"cluster\")+\n  tm_layout(panel.show = TRUE,\n    panel.labels = \"All-Indicator Profiles\",\n    panel.label.fontface = \"bold\",\n    title.position = c(\"left\", \"TOP\"),\n    legend.position = c(\"RIGHT\", \"bottom\"),\n    legend.title.size = 0.9,\n    legend.width = 2)\n\nplots &lt;- list(street, transp, all_ind)\n  \ncurrent.mode &lt;- tmap_mode(\"plot\")\n\n\ntmap mode set to plotting\n\n\nCode\ntmap_arrange(\n    plots,\n    nrow = 1,\n    width = c(0.34, 0.33, 0.33)\n  )\n\n\n\n\n\n\n\n\n\nWe can see that the clustering by street design and/or transportation domain(s) yielded a relatively consistent pattern of neighborhood profiles in Bogotá."
  },
  {
    "objectID": "posts/ZAT_profile_map/ZAT_profile_map.html#assess-variable-influence",
    "href": "posts/ZAT_profile_map/ZAT_profile_map.html#assess-variable-influence",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Assess variable influence",
    "text": "Assess variable influence\nSince these profiles are modeled across the variables (in each domain), we’ll now explore further which variables may be more influential in the clustering result, which will also be important in our interpretation of the different profiles/clusters.\nOne way to do that is to visualize each variable by the ZAT unit and see which variables have a better cluster separation (as in the previous post).\nIn addition, we can examine the mean and variance of each variable see which ones are significantly different across clusters.\n\nStreet Design Domain\n\n\nCode\nzat_std2 &lt;- readRDS(\"../../../../clean_data/ZAT/zat_std2.rds\")\n\nzat_cluster_var &lt;- zat_cluster %&gt;%\n  as.data.frame() %&gt;% \n  select(-geometry) %&gt;% \n  left_join(zat_std2, by = \"ZAT\")\n\nstreet_dm &lt;- c(\"st_4ln_length_log\", \"bikelane_m_log\", \"trlight_per_km2\", \n            \"sttree_per_km2\", \"bridg_per_km2\")\n\ntransportation_dm &lt;- c(\"BUSTOPDENS\", \"bus_length_log\", \"brt_length_log\", \"numrbp_per_km2\")\n\nst_var &lt;- zat_cluster_var %&gt;% \n  select(-ZAT, -transp, -all) %&gt;% \n  pivot_longer(-street, names_to = \"indicator\") %&gt;% \n  filter(indicator %in% street_dm) %&gt;% \n  group_by(street, indicator) %&gt;% \n  mutate(mean = mean(value),\n    sd = sd(value))\n\nMinMeanSDMax &lt;- function(x) {\n  v &lt;- c(mean(x)-3*sd(x), mean(x) - sd(x), mean(x), mean(x) + sd(x), mean(x)+3*sd(x))\n  names(v) &lt;- c(\"ymin\", \"lower\", \"middle\", \"upper\", \"ymax\")\n  v\n}\n\nggplot(st_var, aes(x= factor(street), y =value, fill = factor(street)))+\n  stat_summary(fun.data=MinMeanSDMax, geom=\"boxplot\") +\n  scale_fill_brewer(palette = \"YlGn\") + # Change fill colors\n  theme_minimal() + # Use a minimal theme\n  labs(title = \"Street Design Indicators by Neighborhood Profiles\", \n    x = \"Cluster\", \n    y = \"Value\",\n    fill = \"cluster\") +\n  facet_wrap(~indicator, scales = \"free\", nrow = 1)\n\n\n\n\n\n\n\n\n\nIt looks like the street length (st_4ln_length_log), traffic lights (trlight_per_km2) and pedestrian bridge have the most separation between clusters and therefore are the more influential variables in this model-based clustering result. For street length:\n\n\nCode\nzat_imp_geo &lt;- readRDS(\"../../../../clean_data/zat_imp_geo.rds\")\n\npal &lt;- colorNumeric(\n  palette = \"Blues\",\n  domain = zat_imp_geo$st_4ln_length_log\n)\n\nzat_label &lt;- glue(\"ZAT{zat_imp_geo$ZAT} Street length (log): {zat_imp_geo$st_4ln_length_log}\")\n\nzat_imp_geo %&gt;% \n  select(ZAT, st_4ln_length_log) %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal(st_4ln_length_log),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal,\n            values = ~st_4ln_length_log,\n            title = \"Street length (log) in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\n\n\nCode\npal2 &lt;- colorNumeric(\n  palette = \"viridis\",\n  domain = zat_imp_geo$trlight_per_km2\n)\n\nzat_label2 &lt;- glue(\"ZAT{zat_imp_geo$ZAT} Traffic light/km2: {zat_imp_geo$trlight_per_km2}\")\n\nzat_imp_geo %&gt;% \n  select(ZAT, trlight_per_km2) %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal2(trlight_per_km2),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label2,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal2,\n            values = ~trlight_per_km2,\n            title = \"Traffic light per km2 in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\nIndeed it looks like the cluster 1 (light yellow in the profile map) is corresponding to the neighborhoods that have longer streets (with 4 or more lanes). Although it’s hard to tell on the map due to the zeros, based on the boxplot, these neighborhoods also have a slightly lower pedestrian bridge count and traffic light per km2.\n\n\nTransportation Domain\n\n\nCode\ntransp_var &lt;- zat_cluster_var %&gt;% \n  select(-ZAT, -street, -all) %&gt;% \n  pivot_longer(-transp, names_to =\"indicator\") %&gt;% \n  filter(indicator %in% transportation_dm) %&gt;% \n  group_by(transp, indicator) %&gt;% \n  mutate(mean = mean(value),\n         sd = sd(value))\n\nggplot(transp_var, aes(x= factor(transp), y = value, fill = factor(transp)))+\n  stat_summary(fun.data=MinMeanSDMax, geom=\"boxplot\") +\n  scale_fill_brewer(palette = \"YlGn\") + # Change fill colors\n  theme_minimal() + # Use a minimal theme\n  labs(title = \"Transportation Indicators by Neighborhood Profiles\", \n       x = \"Cluster\", \n       y = \"Value\",\n       fill = \"cluster\") +\n  facet_wrap(~indicator, scales = \"free\", nrow = 1)\n\n\n\n\n\n\n\n\n\nWhile the general pattern of these variables are relatively consistent (despite the large variance), it looks like bus-related variables are more influential than the BRT one (hmm) in the modeling, especially the bus route length (bus_length_log). Looking at the bus route length on a map:\n\n\nCode\npal3 &lt;- colorNumeric(\n  palette = \"magma\",\n  domain = zat_imp_geo$bus_length_log\n)\n\nzat_label3 &lt;- glue(\"ZAT{zat_imp_geo$ZAT} Bus routes length (log): {zat_imp_geo$bus_length_log}\")\n\nzat_imp_geo %&gt;% \n  select(ZAT, bus_length_log) %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal3(bus_length_log),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label3,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal3,\n            values = ~bus_length_log,\n            title = \"Bus routes length (log) in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\nFrom the map and boxplots, cluster 3 (darker green) seem to be corresponding to neighborhoods with few bus routes, whereas cluster 1 and 2 seem to have longer bus routes. It is a little surprising to me that some of the neighborhoods with long bus routes do not have many traffic lights.\nAfter we have more variables perhaps aggregated from street level, we can also use logistic regression model to test the influence of each variable, and try including/excluding different variables to compare the entropy from the model-based clustering."
  },
  {
    "objectID": "posts/zat_hclust_geo/zat_hclust_geo.html",
    "href": "posts/zat_hclust_geo/zat_hclust_geo.html",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "",
    "text": "Previously we have used finite mixture modeling to cluster the neighborhoods (ZATs) across all the ZAT-level indicators on road infrastructures. In this post, we’ll explore another clustering approach, hierarchical clustering, taking into account the spatial relationships of the ZAT units (in addition to the indicators).\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ClustGeo)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(patchwork)"
  },
  {
    "objectID": "posts/zat_hclust_geo/zat_hclust_geo.html#hierarchical-clustering-without-constraint",
    "href": "posts/zat_hclust_geo/zat_hclust_geo.html#hierarchical-clustering-without-constraint",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "Hierarchical Clustering without Constraint",
    "text": "Hierarchical Clustering without Constraint\nFirst, we’ll look at the hierarchical clustering output with the indicators only. We can use a dissimilarity matrix D0 calculated with the indicators.\n\n\nCode\nzat_std2 &lt;- readRDS(\"../../../../clean_data/ZAT/zat_std2.rds\")\n\nD0 &lt;- dist(zat_std2)\ntree &lt;- hclustgeo(D0)\nplot(tree, hang = -1, label = FALSE,\n    xlab = \"\", sub = \"\",\n    main = \"Ward dendrogram with D0 only\")\n\nrect.hclust(tree, k = 4, border = 1:4)\nlegend(\"topright\", legend = paste(\"cluster\", 1:4),\n  fill = 1:4, bty = \"n\", border = \"white\")\n\n\n\n\n\n\n\n\n\nWe can use this dendrogram to illustrate the arrangement of the clusters produced by hierarchical clustering, and the height at which any two clusters are joined together represents the distance or dissimilarity between those clusters. Depending on the linkage method, the dissimilarity is measured differently:\n\nSingle Linkage (Nearest Point): The height indicates the shortest distance between any member of one cluster and any member of another cluster.\nComplete Linkage (Farthest Point): The height shows the longest distance between any member of one cluster and any member of another cluster.\nAverage Linkage: The height represents the average distance between all members of one cluster and all members of the other cluster.\nWard’s Method: The height corresponds to the increase in the total within-cluster variance after merging two clusters.\n\nFor this post, we’ll be using Ward’s Method. And from the dendrogram, we are choosing k = 4 as the component number, as shown above in the different colored rectangles. And the resulting partition looks like this:\n\n\nCode\np4 &lt;- cutree(tree, 4)\nsource(\"../../../../functions/get_cluster.R\")\n\nzat_hclust &lt;- get_cluster(zat_std2, p4)\n\nhclust_geo &lt;- zat %&gt;% \n  mutate(clus = p4) %&gt;% \n  st_zm()\n\n\n\n\nCode\npal &lt;- c(\"#225ea8\",\"#41b6c4\",\"#a1dab4\",\"#fecb3e\")\nsource(\"../../../../functions/cluster_plot.R\")\n\nmap &lt;- ggplot()+\n  geom_sf(data = hclust_geo, fill = pal[hclust_geo$clus])\n\n(cluster_plot(zat_hclust) | map ) + \n  plot_annotation('Hierarchical Clustering with Indicators only', \n    subtitle = 'ZAT level, Bogotá',\n    theme=theme(plot.title=element_text(size=14, face = \"bold\", hjust=0.5),\n                plot.subtitle = element_text(size = 10, face = \"bold\", hjust = 0.5))) +\n  plot_layout(width = c(1, 1.5), height = unit(15, \"cm\"))"
  },
  {
    "objectID": "posts/zat_hclust_geo/zat_hclust_geo.html#hierarchical-clustering-with-spatial-constraint",
    "href": "posts/zat_hclust_geo/zat_hclust_geo.html#hierarchical-clustering-with-spatial-constraint",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "Hierarchical Clustering with Spatial Constraint",
    "text": "Hierarchical Clustering with Spatial Constraint\n\nGeographical distances\nThe first way to include the spatial constraint is through the geographic distances.\n\n\n\n\n\n\nNote\n\n\n\nDistance here is calculated between polygons by st_distances, which is determined by the minimum distance between any two points on the boundary of non-overlapping polygons. For overlapping polygons, the distance is 0.\n\n\nWe can do that by including another matrix D1 with the information of the distances between ZAT units, and setting a mixing parameter alpha in [0, 1] to set the importance of D0 and D1.\n\n\nCode\ndist_zat &lt;- st_distance(zat) #zat being the ZAT-level shapefiles\nD1 &lt;- as.dist(dist_zat)\n\n\nWhen alpha=0 the D1 is not taken into account, and when alpha=1 D0 is not taken into account. To choose an appropriate alpha, we can plot the homogeneity (proportion of explained inertia) of each matrix (Q0 and Q1) using a range of different values of alpha and a given number of cluster (in this case k=4).\n\nWe are choosing alpha=0.35 here where Q0 and Q1 both have relatively high homogeneity. Then we can perform the clustering with geographic distances constraint:\n\n\nCode\ntree &lt;- hclustgeo(D0, D1, alpha = 0.35)\np4_geo &lt;- cutree(tree, 4)\n\nzat_clustgeo &lt;- get_cluster(zat_std2, p4_geo)\n\nclustgeo_geo &lt;- zat %&gt;% \n  mutate(clus = p4_geo) %&gt;% \n  st_zm()\n\n\nAs a result, we have a slightly different clustering output:\n\n\nCode\nmap2 &lt;- ggplot()+\n  geom_sf(data = clustgeo_geo, fill = pal[clustgeo_geo$clus])\n\n(cluster_plot(zat_clustgeo) | map2 ) + \n  plot_annotation(\n    'Hierarchical Clustering with Indicators and Spatial Constraint', \n    subtitle = 'ZAT level, Bogotá',\n    theme=theme(\n     plot.title=element_text(size=14, face = \"bold\", hjust=0.5),\n     plot.subtitle = element_text(size = 10, face = \"bold\", hjust = 0.5)))+\n  plot_layout(width = c(1, 1.5), height = unit(15, \"cm\"))\n\n\n\n\n\n\n\n\n\n\n\nNeighboring status\nAnother way to consider spatial constraint is through the neighboring ZAT units. We can do that by generating another dissimilarity matrix D1 that reflects whether two ZAT units have contiguous boundaries (sharing one or more boundary point).\n\n\nCode\n#determin neighborhoods\nzat_nb &lt;- poly2nb(zat %&gt;% st_zm(), snap = 0.005)\n#generate matrix of neighborhoods (binary)\nA &lt;- nb2mat(zat_nb, style = \"B\")\n#set diagonal value\ndiag(A) &lt;- 1\nD1 &lt;- as.dist(1-A)\n\n\nWe can use a similar strategy to determine the mixing parameter alpha.\n\nIn this case, alpha = 0.2 is chosen for the clustering process.\n\n\nCode\nlibrary(spdep)\nlibrary(sp)\n\ntree &lt;- hclustgeo(D0, D1, alpha = 0.2)\np4_nb &lt;- cutree(tree, 4)\n\nzat_clustnb &lt;- get_cluster(zat_std2, p4_nb)\n\nclustnb_geo &lt;- zat %&gt;% \n  mutate(clus = p4_nb) %&gt;% \n  st_zm()\n\n\nHere is how the results look like:\n\n\nCode\nmap3 &lt;- ggplot()+\n  geom_sf(data = clustnb_geo, fill = pal[clustnb_geo$clus])\n\n(cluster_plot(zat_clustnb) | map3 ) + \n  plot_annotation(\n    'Hierarchical Clustering with Indicators and Neighborhood Constraint', \n    subtitle = 'ZAT level, Bogotá',\n    theme=theme(plot.title=element_text(size=14, face = \"bold\", hjust=0.5),\n      plot.subtitle = element_text(size = 10, face = \"bold\", hjust = 0.5))) +\n  plot_layout(width = c(1, 1.5), height = unit(15, \"cm\"))\n\n\n\n\n\n\n\n\n\n\n\nNeighborhood distances\nIn contrast to geographical distances, neighborhood distances take into account the network between the ZAT units and better reflects the actual distances between neighborhoods (especially when there’s large water body or mountain separating some ZAT units – e.g. Boston).\nWe can first generate the neighborhoods (similar to previous section on neighboring status), and the neighborhood distances we need are the line(s) connecting the neighborhoods, as shown below (queen contiguity):\n\n\nCode\ncentroid &lt;- zat %&gt;% \n  st_zm() %&gt;% \n  st_centroid()\n\nzat_nb &lt;- poly2nb(zat %&gt;% st_zm(), snap = 0.005)\ndist_nb &lt;- nbdists(zat_nb, centroid)\n\nplot(as_Spatial(zat %&gt;% st_zm()), main = \"Neighborhood Network\")\nplot(nb, coords = coordinates(as_Spatial(centroid)), col=\"blue\", add = TRUE)\n\n\n\n\n\n\n\nNext, we’ll construct a data frame for the network with columns representing the origin (from), destination (to) and the corresponding distances to create a matrix of distances by the network for the clustering process (D1).\nSimilarly, we need to determine a mixing parameter alpha by the homogeneity plot:\n\n\nCode\nlibrary(cppRouting)\nlibrary(data.table)\n\n# data frame\nn = length(dist_nb)\nres = data.table(from = integer(), to = integer(), dist = numeric())\nfor(i in seq_len(n)){\n  res = rbind(res, data.table(from = i, to = nb[[i]], dist = dist_nb[[i]]))\n}\n\ngraph  &lt;-  makegraph(res, directed = F)\n\n# distance matrix\ndist_link &lt;- get_distance_matrix(Graph=graph, \n  from = unique(res$from), \n  to = unique(res$to))\n\n# clustering\nD1 &lt;- as.dist(dist_link)\n\n\n\nWe’ll choose alpha = 0.45 in this case for clustering.\n\n\nCode\ntree &lt;- hclustgeo(D0, D1, alpha = 0.45)\np4_nbdist &lt;- cutree(tree, 4)\n\nzat_clustnbdist &lt;- get_cluster(zat_std2, p4_nbdist)\n\nclustnbdist_geo &lt;- zat %&gt;% \n  mutate(clus = p4_nbdist) %&gt;% \n  st_zm()\n\n\nAs a result, we have the following neighborhood profiles:\n\n\nCode\nmap4 &lt;- ggplot()+\n  geom_sf(data = clustnbdist_geo, fill = pal[clustnbdist_geo$clus])\n\n(cluster_plot(zat_clustnbdist) | map4 ) + \n  plot_annotation('Hierarchical Clustering with Indicators and Neighborhood Distances Constraint', \n                  subtitle = 'ZAT level, Bogotá',\n    theme=theme(plot.title=element_text(size=13, face = \"bold\", hjust=0.5),\n      plot.subtitle = element_text(size = 10, face = \"bold\", hjust = 0.5)))+\n  plot_layout(widths = c(1,1.5), heights = unit(15, units = \"cm\"))"
  },
  {
    "objectID": "posts/SES_street/SES_street.html",
    "href": "posts/SES_street/SES_street.html",
    "title": "Summarizing Street-specific SES Level from Block-level Data",
    "section": "",
    "text": "One of the goals in the project is to assess the relationship of socioeconomic status (SES) with pedestrian collisions at the street level. While the street-level collision data is available, the SES data is at the block (manzana) level, and this post describes the process of summarizing SES to the street level.\nThe code used to generate the maps is linked here and table outputs are shared with Alex on Onedrive (Analysis_output_HX2024/SES_street/).\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(readr)\nlibrary(reactable)"
  },
  {
    "objectID": "posts/SES_street/SES_street.html#ses-with-500m-buffer",
    "href": "posts/SES_street/SES_street.html#ses-with-500m-buffer",
    "title": "Summarizing Street-specific SES Level from Block-level Data",
    "section": "1. SES with 500m buffer",
    "text": "1. SES with 500m buffer\n\n1.1 Raw data\nRaw data is located at Bogota/Censo/SHP_MGN2018_INTGRD_MANZ/ in shapefiles format, and includes many variables at the manzana level across Colombia (dictionary included in the folder). For our purposes, we are selecting the following variables related to SES level:\n\n\n\n1.2 Join street-buffer with blocks\nSince blocks are not directly intersecting with streets, we’ll first create buffers around the streets and use the blocks that are intersecting with the buffers to summarize SES for the streets. First, we’ll set the buffer range as 500m, where the borders of the street segment will be extended 500m. Next, we can match each street (buffer) with the intersecting blocks.\nTo visualize what the buffer looks like with the corresponding streets and blocks, we’ll map one street (in purple), its buffer (in orange) and the intersecting blocks (in blue):\n\n\n\n1.3 Summarize street-level average SES\nAfter establishing the relationship between the street-buffer and the intersecting blocks, we can sum the SES-specific and total household counts for all the blocks in each street, followed by calculating the percent of households in each SES category (from E1 to E6, with E9 being unknown).\nAt this point, we have the percent of households in each SES category in the blocks associating with each street. Using weighted mean of the SES level, we can obtained a street-level SES (wt_mean). Since the SES level is a categorical variable, we’ll round the weighted mean (ses_cat) to the nearest integer, with 0.5 rounded up.\nThe resulting table looks like this (first 10 rows):\n\n\n\n\nStreet-level average SES with 500m buffer\n\n\n\n\n1.4 Visualize street-level average SES (500m buffer)\nHere is a map of the summarized SES at the street level, with 6 being the highest SES level and 1 being the lowest."
  },
  {
    "objectID": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html",
    "href": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html",
    "title": "Exploratory Data Analysis of BEPIDL Data",
    "section": "",
    "text": "Building on the initial exploratory data analysis on variable distribution, I’d like to join the spatial information from ZAT folder with the variables from ZAT_INDICADORES.xlsx and visualize the geo-referenced data."
  },
  {
    "objectID": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html#files-included",
    "href": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html#files-included",
    "title": "Exploratory Data Analysis of BEPIDL Data",
    "section": "Files included",
    "text": "Files included\n\nZAT/\nThis folder contains boundary files for the ZAT units – a table of 1141 rows, 6 cols (each row being a ZAT unit); (dropping z dimension to create interactive maps).\n\n\nCode\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(sf)\nlibrary(leaflet)\n\nzat &lt;- st_read(\"../../../../data/ZAT/ZAT_geo/ZAT.shp\")\n\n\nReading layer `ZAT' from data source \n  `D:\\LocalGitHub\\BEPIDL\\data\\ZAT\\ZAT_geo\\ZAT.shp' using driver `ESRI Shapefile'\nSimple feature collection with 1141 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY, XYZ\nBounding box:  xmin: -74.88439 ymin: 3.70344 xmax: -73.05211 ymax: 5.83076\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  MAGNA-SIRGAS\n\n\nCode\nzat %&gt;%\n  st_zm() %&gt;% \n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager) %&gt;%\n  addPolygons()\n\n\n\n\n\n\n\n\nZAT_INDICADORES.xlsx\nThis is a data table of 919 rows, 18 cols (each row being a ZAT unit).\nAccording to the codebook, the indicators in this table seem to be the “old” version. For all the ZAT included, there are no missing data, while some of the values are zeros. As seen from the row count, it contains fewer ZAT units than the shapefiles. (first 10 rows shown below)\n\n\nCode\nzat_data &lt;- read_xlsx(\"../../../../data/ZAT/ZAT_INDICADORES.xlsx\")\nzat_data[1:10,]\n\n\n# A tibble: 10 × 18\n     ZAT `Area M2` areakm2 BUSTOPDENS LONGMV LRDENS BPRDRATE NUMINT INTDENS\n   &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n 1    83  1016244.   1.02       13.8  10852. 10679.   0         100   98.4 \n 2   854   219816.   0.220      18.2   1391.  6330.   0          21   95.5 \n 3    57   513564.   0.514      35.0   6935. 13504.   0          99  193.  \n 4    20   217888.   0.218      18.4   3586. 16460.   0          40  184.  \n 5    18   162708.   0.163      24.6   1083.  6655.   0           6   36.9 \n 6    19   228574.   0.229       0        0      0    0           0    0   \n 7    84   239887.   0.240       0      759.  3163.   0           5   20.8 \n 8   559  1184382.   1.18        0      167.   141.   0           2    1.69\n 9   561   807833.   0.808       3.71 10939. 13542.   0.0603    159  197.  \n10   947   916149.   0.916       8.73 17013. 18570.   0.0677    216  236.  \n# ℹ 9 more variables: NUMTTREES &lt;dbl&gt;, NUMSTTREES &lt;dbl&gt;, NUMBRIDGES &lt;dbl&gt;,\n#   NUMTTFLIGH &lt;dbl&gt;, NUMPTFLIGH &lt;dbl&gt;, NUMRBP &lt;dbl&gt;, LONGRBP &lt;dbl&gt;,\n#   NUMRT &lt;dbl&gt;, LONGRT &lt;dbl&gt;"
  },
  {
    "objectID": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html#joining-geometry-with-data",
    "href": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html#joining-geometry-with-data",
    "title": "Exploratory Data Analysis of BEPIDL Data",
    "section": "Joining Geometry with Data",
    "text": "Joining Geometry with Data\nHere we’ll join the ZAT shapefiles with the ZAT_INDICADORES.xlsx by ZAT ID, keeping the ZAT units that we have data for, resulting in a table of 919 rows and 23 columns.\n\n\nCode\ngeoref_zat &lt;- zat_data %&gt;% \n  left_join(zat, by = \"ZAT\") %&gt;% \n  st_as_sf()"
  },
  {
    "objectID": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html#visualizing-indicators-in-maps",
    "href": "posts/EDA2_georef_ZAT/EDA2_georef_ZAT.html#visualizing-indicators-in-maps",
    "title": "Exploratory Data Analysis of BEPIDL Data",
    "section": "Visualizing Indicators in Maps",
    "text": "Visualizing Indicators in Maps\nWe’ll use the georeferenced data to visualize the indicators in maps (dropping z dimension, datum set to WGS84). With loose categorizing the variables into 3 groups: public transits, road features and traffic lights, we’ll show interactive maps for one variable for each group along with distributions of all variables.\n\nPublic transit\n\n\nCode\nlibrary(glue)\n# set color palette for circles\npal &lt;- colorNumeric(\n  palette = c(\"orange\",\"navy\"),\n  domain = georef_zat$BUSTOPDENS\n)\n\nzat_label &lt;- glue(\"ZAT{georef_zat$ZAT} Bus stop density: {round(georef_zat$BUSTOPDENS,2)}/km2\")\n\ngeoref_zat %&gt;%\n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal(BUSTOPDENS),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              ) %&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal,\n            values = ~BUSTOPDENS,\n            title = \"Bus Stop Density in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\n\n\n\n\n\nCode\nzat_data_long &lt;- zat_data %&gt;% \n  select(-2, -3) %&gt;% \n  pivot_longer(-ZAT, names_to = \"indicator\")\n\nbus &lt;- c('BUSTOPDENS', 'NUMRBP', 'LONGRBP', 'NUMRT', 'LONGRT')\nonroad &lt;- c('LONGMV', 'LRDENS', 'BPRDRATE', 'NUMINT', 'INTDENS')\ntlight &lt;- c('NUMTTFLIGH', 'NUMPTFLIGH')\nbyroad &lt;- c('NUMTTREES', 'NUMSTTREES', 'NUMBRIDGES')\n  \nzat_data_long %&gt;% \n  filter(indicator%in%all_of(bus)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\")+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal() +\n  labs(title = \"Distribution of Indicators related to Bus/BRT\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nRoad features\n\n\nCode\npal2 &lt;- colorNumeric(\n  palette = c(\"orange\",\"navy\"),\n  domain = georef_zat$INTDENS\n)\n\nzat_label2 &lt;- glue(\"ZAT{georef_zat$ZAT} Intersection density: {round(georef_zat$INTDENS,2)}/km2\")\n\ngeoref_zat %&gt;%\n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal2(INTDENS),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label2,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              ) %&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal2,\n            values = ~INTDENS,\n            title = \"Intersection Density in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\n\n\nCode\nzat_data_long %&gt;% \n  filter(indicator%in%all_of(onroad)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\")+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal()+\n  labs(title = \"Distribution of Indicators related to Features on the Road\") +\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nCode\nzat_data_long %&gt;% \n  filter(indicator%in%all_of(byroad)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\", alpha = 0.7)+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal()+\n  labs(title = \"Distribution of Indicators related to Features by the Road\") +\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nTraffic lights\n\n\nCode\npal3 &lt;- colorNumeric(\n  palette = c(\"orange\",\"navy\"),\n  domain = georef_zat$NUMTTFLIGH\n)\n\nzat_label3 &lt;- glue(\"ZAT{georef_zat$ZAT} Total traffic lights: {georef_zat$NUMTTFLIGH}\")\n\ngeoref_zat %&gt;%\n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal3(NUMTTFLIGH),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label3,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              ) %&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal3,\n            values = ~NUMTTFLIGH,\n            title = \"Total Traffic Lights in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\n\n\nCode\nzat_data_long %&gt;% \n  filter(indicator%in%all_of(tlight)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\", alpha = 0.7)+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal()+\n  labs(title = \"Distribution of Indicators about Traffic Lights\") +\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\nInitial takeaway: some of the indicators seem to show similar spatial patterns, though there is a significant number of lower count values in the dataset which might make the visualization less clear."
  },
  {
    "objectID": "posts/collision_RR/collision_RR.html",
    "href": "posts/collision_RR/collision_RR.html",
    "title": "Pedestrian Collision, SES Level and Street Features",
    "section": "",
    "text": "The goal of this post is to visualize the relationship between pedestrian collision, socioeconomic status and street features, both at the street level and the neighborhood (ZAT) level.\nThe table outputs are shared with Alex on Onedrive (Analysis_output_HX2024/association_w_collision/).\nCode\nlibrary(dplyr)\nlibrary(ggplot2)"
  },
  {
    "objectID": "posts/collision_RR/collision_RR.html#street-level-analysis",
    "href": "posts/collision_RR/collision_RR.html#street-level-analysis",
    "title": "Pedestrian Collision, SES Level and Street Features",
    "section": "1. Street Level Analysis",
    "text": "1. Street Level Analysis\n\n1.1 Collision and Road Type\nUsing collision data from Calles_datos and road type data from IDECA/GDR_V12.20.gdb, we can construct a table of pedestrian collision count and road type by the street. Road type is categorized as “Arterial”, “Collector”, “Local”, “Pedestrian”, “Rural” and “Unknown”. For our analysis, we’ll group “Pedestrian”, “Rural” and “Unknown” as “Other”. All comparisons are relative to the “Arterial” type.\n\n\nCode\nsource(\"../../../../functions/plot_RR.R\")\n\nplot_RR(road_type, road_type2)+\n  labs(\n    title = \"Pedestrian Collision and Road Type\",\n    subtitle = \"Street level, Bogotá, Colombia\",\n    x = \"RR (95%CI)\",\n    y = \"Road Type\",\n    caption = \"All comparisons are relative to the 'Arterial' road type.\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n1.2 Collision and Street Features\nAmong the street features included in Calles_datos, we’re selecting 20 individual features and assess their association with pedestrian collision. The street features are either count or continuous measures, and we’re dividing the values into tertiles (“Low”, “Medium”, “High”) to examine the effects of these variables at different levels.\n\n\nCode\nfeature_RR &lt;- st_feature %&gt;% \n  filter(!term == \"(Intercept)\",\n    !term == \"st_dir2\") #st_dir2 no difference\n\nfeature_RR %&gt;% \n  ggplot(aes(x = estimate, y = category))+\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill = predictor), alpha = 1) +\n  scale_fill_manual(values = rep(c(\"#ffffff00\", \"#f0f0f090\"), 20), guide = \"none\")+ \n  geom_errorbar(aes(xmax = conf.high, xmin = conf.low), linewidth = 0.5)+\n  geom_point(aes(x = estimate), size = 2)+\n  geom_vline(aes(xintercept = 1), linetype = 2) +\n  facet_grid(rows = vars(predictor), scales = \"free_x\", switch = \"y\")+\n  #scale_x_continuous(breaks = c(1, 4, 8, 12), labels = c(\"1\",\"4\", \"8\", \"12\"))+\n  scale_x_continuous(breaks = sort(round(c(seq(min(feature_RR$conf.low), max(feature_RR$conf.high), length.out = 4), 1), 0)))+\n  theme_bw()+\n # scale_fill_manual(values = c(\"Medium\" = \"#ffffff00\", \"High\" = \"#f0f0f090\"), guide = \"none\") +\n  labs(\n    title = \"Pedestrian Collision and Street Features\",\n    subtitle = \"Street level, Bogotá, Colombia\",\n    x = \"RR (95%CI)\",\n    y = \"Street Features\",\n    caption = \"Tertiles of street feature values are used in analysis.\\n All comparisons are relative to the 'Low' category.\"\n    )+\n  theme(\n    plot.title = element_text(size = 13, face = \"bold\", hjust = 0),\n    text = element_text(size = 11),\n    axis.title = element_text(size = 12),\n   # plot.title.position = \"plot\",\n    panel.spacing.y = unit(0, \"points\"),\n    panel.border = element_blank(),\n    #axis.text.y = element_blank(),\n    axis.ticks.length.y = unit(0, \"points\"),\n    strip.text.y.left = element_text(face = \"bold\", angle = 0),\n    strip.background.y = element_blank(),\n    strip.placement = \"outside\",\n    axis.line = element_line()\n  )\n\n\n\n\n\n\n\n\n\n\n\n1.3 Collision and SES Level\nUsing block-level data and street boundary buffers to assign SES level to street units (discussed in previous post), we can study the association between pedestrian collision and SES level. SES levels range from 1-6 (categorical), with 1 being the lowest and 6 being the highest. The relative risks for collision at different SES level are shown below, where 100 and 500 represent the range street boundary buffers (in meters).\n\n\nCode\nplot_RR(ses_collision, predictor)+\n  facet_grid(vars(buffer_m), switch = \"y\")+\n  theme(\n    strip.text.y.left = element_text(face = \"bold\", angle = 90),\n    strip.background.y = element_rect(fill = \"white\"),\n    strip.placement = \"outside\",\n  )+\n  labs(\n    title = \"Pedestrian Collision and Socioeconomic Status (SES)\",\n    subtitle = \"Street level, Bogotá, Colombia\",\n    x = \"RR (95%CI)\",\n    y = \"SES Level\",\n    caption = \"All comparisons are relative to the 'ses_6' (highest) level.\"\n  )"
  },
  {
    "objectID": "posts/collision_RR/collision_RR.html#neighborhood-level-analysis",
    "href": "posts/collision_RR/collision_RR.html#neighborhood-level-analysis",
    "title": "Pedestrian Collision, SES Level and Street Features",
    "section": "2. Neighborhood Level Analysis",
    "text": "2. Neighborhood Level Analysis\n\n2.1 Collision and SES level\nAt neighborhood (ZAT) level, pedestrian collision is aggregated from raw data (point) to each ZAT boundary. In addition to total pedestrian collision (total), we are including sub-categories of collision with injuries (injury) and collision with deaths(death). Block-level SES is also aggregated to ZAT level, using weighted mean of the percent of households in each SES category.\n\n\nCode\nplot_RR(ses_col_zat, predictor) +\n  facet_grid(vars(outcome), switch = \"y\")+\n  labs(\n    title = \"Pedestrian Collision and Neighborhood SES Level\",\n    subtitle = \"ZAT level, Bogotá, Colombia\",\n    x = \"RR (95%CI)\",\n    y = \"SES Level\",\n    caption = \"All comparisons are relative to the SES 6 (highest) level.\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n2.2 Collision and Profiles\nNext, we are looking at the relationship between pedestrian collision and the neighborhood profiles generated from hierarchical clustering using street- and ZAT-level BE features with spatial constraint.\n\n\n\nCode\nplot_RR(profile_col_zat, predictor)+\n  facet_grid(vars(outcome), switch = \"y\")+\n  labs(\n    title = \"Pedestrian Collision and Neighborhood Profiles\",\n    subtitle = \"ZAT level, Bogotá, Colombia\",\n    x = \"RR (95%CI)\",\n    y = \"ZAT Profile\",\n    caption = \"All comparisons are relative to the profile 1.\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n2.3 Collision, Profiles and SES Level\nAt last, we’ll assess the combined effect of the neighborhood profiles and SES level on pedestrian collision.\n\n\nCode\nplot_RR(ses_prof_col, predictor)+\n  facet_grid(vars(outcome), switch = \"y\")+\n  labs(\n    title = \"Pedestrian Collision, Neighborhood Profile and SES Level\",\n    subtitle = \"ZAT level, Bogotá, Colombia\",\n    x = \"RR (95%CI)\",\n    y = \"SES Level and Profile\",\n    caption = \"All comparisons are relative to the SES 6 (highest level) and profile 1.\"\n  )"
  },
  {
    "objectID": "posts/calle_2_zat/calle_2_zat.html",
    "href": "posts/calle_2_zat/calle_2_zat.html",
    "title": "Expanding the Neighborhood-Level Database",
    "section": "",
    "text": "To include more indicators at the ZAT level for our neighborhood built environment profiling, we’ll describe the process of aggregating some of street-level variables to the ZAT level.\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(glue)\nlibrary(knitr)"
  },
  {
    "objectID": "posts/calle_2_zat/calle_2_zat.html#caveat-in-street-zat-spatial-join",
    "href": "posts/calle_2_zat/calle_2_zat.html#caveat-in-street-zat-spatial-join",
    "title": "Expanding the Neighborhood-Level Database",
    "section": "Caveat in Street-ZAT Spatial Join",
    "text": "Caveat in Street-ZAT Spatial Join\nBoth the street-level and ZAT-level geometries are polygons, and the street-level ones are not always nested in the ZAT-level ones. This can pose a problem in spatial joining: while setting the criteria as one within another (st_contains, st_within, st_covers) leaves many streets unmatched to any ZAT unit, setting the criteria as one has any point in common with another (st_intersects) results in many streets matching to multiple ZAT units. For example, below is the map of randomly selected 100 streets with which multiple ZAT units are matched (purple is the border of street, blue is the border of ZAT).\n\n\nCode\ncalle_multi_sub_leaf &lt;- readRDS(\"../../../../clean_data/calle2zat_aggr/calle_multi_sub_leaf.rds\")\nzat_sub_leaf &lt;- readRDS(\"../../../../clean_data/calle2zat_aggr/zat_sub_leaf.rds\")\n\nleaflet() %&gt;% \n  addTiles() %&gt;% \n  addPolygons(data = calle_multi_sub_leaf, weight = 3, fillColor = 'purple', color = 'purple') %&gt;% \n  addPolygons(data = zat_sub_leaf, weight = 3, fillColor = 'blue', color = 'blue') \n\n\n\n\n\n\nAs we can see from zooming in the map, many of the major roads are in fact the border of ZAT unit, and these streets will either be matched to multiple ZAT unit (as shown in the map) using the method of st_intersects, or be matched to non of the ZAT units (missing values) using st_within or other similar methods.\nOf note, by st_within, there are 14878 (~15%) street units with unmatched ZAT units (shown below), whereas by st_intersect, there were 16 unmatched streets."
  },
  {
    "objectID": "posts/calle_2_zat/calle_2_zat.html#divide-and-distribute",
    "href": "posts/calle_2_zat/calle_2_zat.html#divide-and-distribute",
    "title": "Expanding the Neighborhood-Level Database",
    "section": "Divide and Distribute",
    "text": "Divide and Distribute\nPotential approaches to address the caveat are:\n\nAdding from the original data of the signals and other new features that are not found in ZAT.\nAssigning street data to any ZAT that crosses them, but this could result in counting things multiple times.\nDividing the counts in street data by the number of ZATs, then allocate or distribute the divided value into each ZAT.\n\nHere, we’ll use the third option, dividing and distributing.\nWe first create a column indicating the number of ZATs that each street is matched to (match_n), append that column to the street data (calle_clean), then divide the value for each variable of each street by match_n. We’ll select two streets that we know are matched to multiple ZATs (CL1000 and CL4462), and show the values of a few variables before (top) and after (bottom) the dividing process.\n\n\nCode\ncalle_clean &lt;- readRDS(\"calles/calle_clean.rds\")\n\ncalle_zat_xwalk &lt;- calle_zat2 %&gt;% as.data.frame() %&gt;%\n  select(-geometry) %&gt;% \n  add_count(CodigoCL, name = \"match_n\") \n\ncalle_match_n &lt;- calle_clean %&gt;% \n  as.data.frame() %&gt;% \n  select(-geometry) %&gt;% \n  left_join(calle_zat_xwalk %&gt;% select(-ZAT) %&gt;% distinct(), by = \"CodigoCL\")\n\ncalle_n_divide &lt;- calle_match_n %&gt;% \n  select(-puente_vh, -Puente_PT) %&gt;% \n  mutate(\n    across(-c(CodigoCL,area, match_n), ~.x/match_n, .names = \"{.col}\")\n    ) # remember the \"match_n\"\n\ncheckCL &lt;- c(\"CL1000\", \"CL4462\")\n\ncalle_match_n %&gt;% filter(CodigoCL %in% checkCL) %&gt;% \n  select(CodigoCL, area, match_n, AVE_pendie, A_Calzada, arboles)\n\ncalle_n_divide %&gt;% filter(CodigoCL %in% checkCL) %&gt;% \n  select(CodigoCL, area, match_n, AVE_pendie, A_Calzada, arboles)\n\n\n\n\n\n\n\nCodigoCL\narea\nmatch_n\nAVE_pendie\nA_Calzada\narboles\n\n\n\n\nCL1000\n2632.239\n2\n0.0221\n1407.66\n0\n\n\nCL4462\n49696.739\n6\n0.0478\n15487.68\n1146\n\n\n\n\n\n\n\n\nCodigoCL\narea\nmatch_n\nAVE_pendie\nA_Calzada\narboles\n\n\n\n\nCL1000\n2632.239\n2\n0.0110500\n703.83\n0\n\n\nCL4462\n49696.739\n6\n0.0079667\n2581.28\n191\n\n\n\n\n\nAfter this “adjusting” process, we use the resulting values for aggregation, either by taking the weighted mean or the sum.\n\n\n\n\n\n\nNote\n\n\n\nBridge counts (puente_vh, puente_PT) were excluded because they’re character values, and we can consider recoding them into 1 or 0. For aggregation, while the sum is taken for most of the street-level variables, area-weighted mean is taken for AVE_pendie, P_Ancho_Cl, sent_vial, velcidad.\n\n\n\n\nCode\ncalle2zat_df &lt;- calle_zat_xwalk %&gt;% \n  select(-match_n) %&gt;% \n  left_join(calle_n_divide, by = \"CodigoCL\") %&gt;% \n  group_by(ZAT) %&gt;% \n  summarise(\n    across(c(AVE_pendie, P_Ancho_Cl, sent_vial, velcidad), ~weighted.mean(.x, w=area), .names = \"{.col}\"),\n    across(-c(CodigoCL, AVE_pendie, P_Ancho_Cl, sent_vial, velcidad), ~sum(.x), .names = \"{.col}\")\n  )\n\n\nAfter aggregation, we can join the data with ZAT-level geometry (code not included here, refer to initial look post) to create a geo-referenced database for downstream modeling."
  },
  {
    "objectID": "posts/calle_2_zat/calle_2_zat.html#visualize-the-aggregated-data",
    "href": "posts/calle_2_zat/calle_2_zat.html#visualize-the-aggregated-data",
    "title": "Expanding the Neighborhood-Level Database",
    "section": "Visualize the Aggregated Data",
    "text": "Visualize the Aggregated Data\nWe still need to normalize the aggregated values by area, and perhaps take natural logs for some variables. But here, as an example, we’ll map the aggregated average road width (P_Ancho_Cl) and area of sidewalks (A_andenes) at the ZAT level.\n\nAverage Road Width\n\n\nCode\ncalle2zat &lt;- readRDS(\"../../../../clean_data/calle2zat_aggr/calle2zat.rds\")\n\npal &lt;- colorNumeric(\n  palette = \"BrBG\",\n  domain = calle2zat$P_Ancho_Cl\n)\n\nzat_label &lt;- glue(\"ZAT{calle2zat$ZAT} Road width: {calle2zat$P_Ancho_Cl}\")\n\ncalle2zat %&gt;% \n  select(ZAT, P_Ancho_Cl) %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal(P_Ancho_Cl),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal,\n            values = ~P_Ancho_Cl,\n            title = \"Average Road Width in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)\n\n\n\n\n\n\n\n\nSidewalk Areas\n\n\nCode\npal2 &lt;- colorNumeric(\n  palette = \"YlGnBu\",\n  domain = calle2zat$A_andenes\n)\n\nzat_label2 &lt;- glue(\"ZAT{calle2zat$ZAT} Sidewalk area: {calle2zat$A_andenes}\")\n\ncalle2zat %&gt;% \n  select(ZAT, A_andenes) %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"grey\", \n              weight = 0.3,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal2(A_andenes),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label2,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal2,\n            values = ~A_andenes,\n            title = \"Sidewalk Areas in Bogotá&lt;/br&gt;(ZAT-level)\",\n            opacity = 1)"
  },
  {
    "objectID": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html",
    "href": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "",
    "text": "Code\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ClustGeo)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(patchwork)\nlibrary(readxl)"
  },
  {
    "objectID": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html#aggregation-from-calle-to-zat",
    "href": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html#aggregation-from-calle-to-zat",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "Aggregation from calle to ZAT",
    "text": "Aggregation from calle to ZAT\nFirst, we’ll aggregate a few calle level indicators to ZAT level for clustering. Here, for the calles matching to multiple ZAT units, we are making replicates of the calles and distribute them to each matched ZAT unit. We take the area-weighted average of road width and lanes, and sum of the areas of calzada, separado and andenes. After aggregation, for areas in m2, we are converting the unit to km2 and adjusting by the ZAT area in km2 to keep it consistent with the ZAT-level data.\n\n\nCode\ncalle_zat_xwalk &lt;- readRDS(\"calle_zat_xwalk.rds\")\n\ncalle_clean_df &lt;- readRDS(\"calles/calle_clean_df.rds\")\n\ncalle_rename_df &lt;- calle_clean_df %&gt;%   \n  rename_with(~ tolower(.), area:X9ceder_el) %&gt;% \n  rename(\n    area_calle = area,\n    trees = arboles,\n    grade = ave_pendie,\n    road_width = p_ancho_cl,\n    area_roadway = a_calzada,\n    area_median = a_separado,\n    vehicle_bridge = puente_vh,\n    ped_bridge = puente_pt,\n    area_sidewalk = a_andenes,\n    brt_routes = rutas_trm,\n    bus_routes = rutas_sitp,\n    bus_stops = parad_sitp,\n    bus_lanes = caril_sitp,\n    bike_length = largo_cicl,\n    road_marks = sen_horizo,\n    warning_signs = se_hor_seg,\n    road_signs = sen_vert,\n    traffic_lights = semaforo,\n    road_segments = segme_via,\n    speed_limit = velcidad,\n    num_lanes_total = sum_carril,\n    num_lanes_avg = av_carrile,\n   # road_signs_inv = sen_v_inv,\n    stop_signs = s_pare_inv,\n    lturn_sign = x1_girar_iz,\n    bike_signs = x2_ciclov.,\n    bus_signs = x3bus_o_tra,\n    pedxwalk_signs = x4peatonale,\n    speed_bump_signs = x5policiasa,\n    stop_signs2 = x6pare,\n    parking_signs = x7estaciona,\n    school_zone_signs = x8zonas_esc,\n    yield_signs = x9ceder_el\n  )\n\nrep_calle_zat &lt;- calle_rename_df %&gt;%\n  select(CodigoCL, area_calle, area_roadway, area_median, area_sidewalk,\n    road_width, road_marks, road_signs, pedxwalk_signs) %&gt;% \n  left_join(calle_zat_xwalk, by = \"CodigoCL\") %&gt;% \n  drop_na(ZAT) %&gt;% #still need to remove NA here\n  uncount(match_n)\n\nrep_calle_zat_agg &lt;- rep_calle_zat %&gt;% \n  group_by(ZAT) %&gt;% \n  summarise(\n    across(road_width, ~weighted.mean(.x, w=area_calle), .names = \"{.col}\"),\n    across(-c(CodigoCL, road_width), ~sum(.x), .names = \"{.col}\")\n  )\n\nzat_std2n &lt;- readRDS(\"ZAT/zat_std2n.rds\")\n\narea &lt;- zat_std2n %&gt;%\n  select(ZAT, areakm2)\n\nrep_calle_zat_agg2 &lt;- rep_calle_zat_agg %&gt;% \n  select(-area_calle) %&gt;% \n  left_join(area, by = \"ZAT\") %&gt;% \n  mutate(\n    across(c(area_roadway, area_median, area_sidewalk, \n      road_marks, road_signs, pedxwalk_signs), ~.x/areakm2),\n    across(c(area_roadway, area_median, area_sidewalk), ~.x/1000) #to km2\n  )\n\ncalle_2_zat_rep &lt;- rep_calle_zat_agg2 %&gt;% \n  select(-areakm2) %&gt;% #we don't want this in clustering much\n  left_join(zat_std2n %&gt;% select(-areakm2), by = \"ZAT\") #areakm2 already included"
  },
  {
    "objectID": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html#hierarchical-clustering-with-spatial-constraint",
    "href": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html#hierarchical-clustering-with-spatial-constraint",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "Hierarchical Clustering with Spatial Constraint",
    "text": "Hierarchical Clustering with Spatial Constraint\nUsing a similar approach to the previous post, we’ll first use only the aggregated calle data with the ZAT data (indicator matrix D0) for the clustering process to determine the cluster number.\n\nKeeping the cluster number as 4, we’ll calculate the neighborhood distance matrix (D1) using the network distance. To choose a mixing parameter, we’ll take a look at the homogeneity plot:\n\nChoosing 0.25 as the mixing parameter, we can perform the hierarchical clustering and visualize the result:\n\n\nCode\npal &lt;- c(\"#225ea8\",\"#41b6c4\",\"#a1dab4\",\"#fecb3e\")\nsource(\"../../../../functions/cluster_plot.R\")\n\nmap_clust &lt;- ggplot()+\n  geom_sf(data = zat_shapefile %&gt;% st_zm(), color = \"grey70\")+\n  geom_sf(data = calle2zat_geo, color = \"grey70\", fill = pal[calle2zat_geo$clus])\n\n(cluster_plot(calle2zat_clust) | map_clust ) + \n  plot_annotation('Hierarchical Clustering with Indicators and Neighborhood Constraint', \n    subtitle = 'ZAT level and aggregated calle level, Bogotá',\n    theme=theme(plot.title=element_text(size=14, face = \"bold\", hjust=0.5),\n                plot.subtitle = element_text(size = 10, face = \"bold\", hjust = 0.5))) +\n  plot_layout(width = c(1, 1.5), height = unit(20, \"cm\"))"
  },
  {
    "objectID": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html#traffic-flow-and-population",
    "href": "posts/calle2zat_hclust_geo/calle2zat_hclust_geo.html#traffic-flow-and-population",
    "title": "Hierarchical Clustering with Spatial Constraint",
    "section": "Traffic flow and Population",
    "text": "Traffic flow and Population\nTo visualize and compare the neighborhood profile with traffic flow (total walking trips and public transit trips) and population at the ZAT level:\n\n\nCode\n#traffic flow\ntotal_trips &lt;- readRDS(\"../../../../data/zat_denom.rds\")\n\nwalk_transit &lt;- total_trips %&gt;% \n  select(ZAT, total_walk, total_pubt) %&gt;% \n  mutate(flow = total_walk+total_pubt) %&gt;% \n  select(-total_walk, -total_pubt)\n\nwalk_transit_geo &lt;- walk_transit %&gt;% \n  left_join(zat_shapefile, by = \"ZAT\") %&gt;% \n  filter(!st_is_empty(geometry)) %&gt;% \n  st_as_sf() %&gt;% \n  st_zm()\n\nmap_flow &lt;- ggplot()+\n  geom_sf(data = zat_shapefile %&gt;% st_zm(), color = \"grey70\")+\n  geom_sf(data = walk_transit_geo, aes(fill = flow), color = \"grey70\")+\n  scale_fill_viridis_c() +\n  labs(fill = \"Traffic Flow\")+\n  theme_minimal()+  # note the order of adjusting theme\n  theme(\n    legend.position = c(0.9, 0.2),\n    axis.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n# population \npop &lt;- read_excel(\"../../../../data/pop_zat.xlsx\")\n\nzat_pop2021 &lt;- pop %&gt;% \n  select(ZAT, POBD2021) %&gt;% \n  left_join(zat_shapefile, by = \"ZAT\") %&gt;% \n  filter(!st_is_empty(geometry)) %&gt;%\n  st_as_sf() %&gt;% \n  st_zm()\n  \n\nmap_pop &lt;- ggplot() +\n  geom_sf(data = zat_shapefile %&gt;% st_zm(), color = \"grey70\") +\n  geom_sf(data = zat_pop2021, color = \"grey70\", aes(fill = POBD2021)) +\n  scale_fill_viridis_c() +\n  labs(fill = \"Population\")+\n  theme_minimal()+  \n  theme(\n    legend.position = c(0.9, 0.2),\n    axis.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\nmap_clust2 &lt;- ggplot()+\n  geom_sf(data = zat_shapefile %&gt;% st_zm(), color = \"grey70\")+\n  geom_sf(data = calle2zat_geo, color = \"grey70\", aes(fill = factor(clus)))+\n  scale_fill_manual(values = pal) +\n  labs(fill = \"Cluster\")+\n  theme_minimal()+\n  theme(\n    legend.position = c(0.9, 0.2),\n    axis.text = element_blank(),\n    panel.grid = element_blank()\n  )\n  \n(map_clust2 | map_flow | map_pop)+ \n  plot_annotation('Neighborhood Profiles, Traffic Flows and Population', \n    subtitle = 'ZAT level, Bogotá',\n    theme=theme(plot.title=element_text(size=14, face = \"bold\", hjust=0.5),\n                plot.subtitle = element_text(size = 10, face = \"bold\", hjust = 0.5)))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "BEPIDL Study - Notes",
    "section": "",
    "text": "Welcome! I’m Heli, a data analyst at Drexel Urban Health Collaborative, and this is home of the notes from Built Environment, Pedestrian Injuries and Deep Learning (BEPIDL) Study, a project led by Dr. Alex Quistberg and funded by NIH. You can find out more about the project on the NIH website."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BEPIDL-Notes",
    "section": "",
    "text": "Pedestrian Collision, SES Level and Street Features\n\n\n\n\n\n\n\n\n\n\n\nMay 21, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nSummarizing Street-specific SES Level from Block-level Data\n\n\n\n\n\n\n\n\n\n\n\nMay 6, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nDiagnostic Evaluation of an AI Model for Built Environment Features\n\n\nPart 2: Comparing GIS, AI training data and predictions with CANVAS data\n\n\n\n\n\n\n\n\nApr 22, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nDiagnostic Evaluation of an AI Model for Built Environment Features\n\n\nPart 1: Comparing annotators’ reports, AI training data and predictions with GIS data\n\n\n\n\n\n\n\n\nApr 17, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nHierarchical Clustering with Spatial Constraint\n\n\nwith ZAT- and calle-level indicators in Bogotá\n\n\n\n\n\n\n\n\nMar 27, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nHierarchical Clustering with Spatial Constraint\n\n\nwith ZAT indicators in Bogotá\n\n\n\n\n\n\n\n\nMar 14, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nExpanding the Neighborhood-Level Database\n\n\nAggregating street-level data to neighborhood (ZAT) level\n\n\n\n\n\n\n\n\nFeb 28, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nTraffic Sign Data Cleaning\n\n\nGrouping by individual types of traffic signs\n\n\n\n\n\n\n\n\nFeb 21, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nNeighborhood Built Environment Profiles in Bogotá\n\n\nSpatial visualization | Assess variable influence\n\n\n\n\n\n\n\n\nFeb 12, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nNeighborhood Built Environment Profiles in Bogotá\n\n\nFinite mixture modeling with ZAT-level data\n\n\n\n\n\n\n\n\nFeb 7, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nStreet Level Variables\n\n\nPart 1: Road Infrastructure\n\n\n\n\n\n\n\n\nJan 29, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nExploratory Data Analysis of BEPIDL Data\n\n\nGeo-referenced ZAT-level Indicators\n\n\n\n\n\n\n\n\nJan 23, 2024\n\n\nHeli Xu\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Look into BEPIDL Data\n\n\nZAT and Street Level\n\n\n\n\n\n\n\n\nJan 17, 2024\n\n\nHeli Xu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Calles_var/calles_var.html",
    "href": "posts/Calles_var/calles_var.html",
    "title": "Street Level Variables",
    "section": "",
    "text": "From the first look, the street-level variables names in Calles_datos/ seemed a bit confusing, but after cross-referencing the codebook with CRUCES_DATOS.xlsx and variables in siniestros/, we have gained a much better understanding of what they mean. The column names in Calles_datos/and their corresponding description from the codebook are organized into codebook_calles-var.xlsx for future reference (there’re also a few uncertain variables to be confirmed/better defined).\nIn this post, we’ll describe the data cleaning process and explore the distributions of the variables related to road infrastructure at the street level."
  },
  {
    "objectID": "posts/Calles_var/calles_var.html#data-cleaning",
    "href": "posts/Calles_var/calles_var.html#data-cleaning",
    "title": "Street Level Variables",
    "section": "Data Cleaning",
    "text": "Data Cleaning\nAs mentioned in the first look, the data included in Calles_datos/ is a geo-referenced table with 100,819 street units (rows) and 66 attributes (columns, including street id and variables).\nIf we look at the histogram of total area and roadway area, we’ll see there’re a lot of very small streets with area close to 0, which may not be very useful for our downstream analysis.\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n\n\n\nCode\ncalle %&gt;% \n  as.data.frame() %&gt;% \n  select(CodigoCL,total_area = area, roadway_area = A_Calzada) %&gt;% \n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\", binwidth = 50)+\n  theme_minimal()+\n  facet_wrap(~variables)+\n  labs(title = \"Distribution of Street-level Roadway and Total Areas\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 13),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\nSorting the roadway area in ascending order, and zooming in on the smallest side, we take the first 500 rows (street units) of data:\n\n\nCode\ncalle %&gt;% \n    as.data.frame() %&gt;% \n    select(CodigoCL,total_area = area, roadway_area = A_Calzada) %&gt;% \n    arrange(total_area) %&gt;% \n    slice(1:500) %&gt;% \n    pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n    ggplot(aes(x=value)) +\n      geom_histogram(fill = \"skyblue\", color = \"blue\", binwidth = 0.5)+\n      theme_minimal()+\n      facet_wrap(~variables)+\n  labs(title = \"Distribution of Street-level Roadway and Total Areas\",\n    subtitle = \"for 500 street units with the smallest roadways\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = element_text(size = 13)\n  )\n\n\n\nIf we leave out the values that are too small, for example here we’re choosing anything below 5m2, the 500 street units with the smallest roadways will look like this:\n\n\nCode\ncalle %&gt;% \n    as.data.frame() %&gt;% \n    select(CodigoCL,total_area = area, roadway_area = A_Calzada) %&gt;% \n    filter(roadway_area &gt; 5 ) %&gt;% \n    arrange(total_area) %&gt;% \n    slice(1:500) %&gt;% \n    pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n    ggplot(aes(x=value)) +\n    geom_histogram(fill = \"skyblue\", color = \"blue\", binwidth = 0.5)+\n    theme_minimal()+\n    facet_wrap(~variables)+\n  labs(title = \"Distribution of Street-level Roadway and Total Areas\",\n    subtitle = expression(\"for 500 street units with the smallest roadways &gt;5\"* m^2))+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = element_text(size = 13)\n  )\n\n\n\nAt this point, our dataset went from 100,819 rows to 99,560 rows. I included one extra step here in an attempt to clean it further, by adding all the numeric columns for each row (except the ones for id, area-related and speed limit) and leaving out the rows that have a sum of less than 1. Considering most of the variables are counts of certain features, this step will remove the street units that have almost none of the feature that we’re studying. The resulting table now has 99,533 rows.\nIn addition, we’re also removing the columns that contain arbitrary IDs, repeated labels, summarization columns (that add up certain columns), and a few uncertain variables. For the character column sent_vial , we are recoding “uno” and “doble” to the numeric value 1 and 2, and set “SinD*” (no assigned direction) as numeric value 0.\n\n\nCode\ncalle_clean &lt;- calle %&gt;%\n  filter(A_Calzada &gt; 5) %&gt;%\n  select(\n    -c(CODIGO_IDE,\n      FID_EP_IND,\n      Etiquetas,\n      Etiqueta_1,\n      sen_v_inv,\n      comp_cl,\n      OID_,\n      Total_gene,\n      Total_ge_1)\n  ) %&gt;%\n  mutate(total = rowSums(pick(\n    where(is.numeric),\n    -c(sent_vial,\n      puente_vh,\n      Puente_PT,\n      velcidad,\n      area,\n      A_Calzada,\n      CodigoCL)\n  ))) %&gt;% #99560row\n  ##much much faster, see rowwise ops with dplyr\n  filter(total &gt;= 1) %&gt;% #99533rows\n  select(-total) %&gt;%\n  mutate(sent_vial = case_match(sent_vial, \"uno\" ~ 1, \"doble\" ~ 2, \"SinD*\" ~ 0))"
  },
  {
    "objectID": "posts/Calles_var/calles_var.html#variables-about-road-features",
    "href": "posts/Calles_var/calles_var.html#variables-about-road-features",
    "title": "Street Level Variables",
    "section": "Variables about Road Features",
    "text": "Variables about Road Features\nFor better visualization, we’re (again, loosely) categorizing the variables into several groups, based on the common domains used with road infrastructure features. Below is the domain and the variables involved:\n\nRoad Geometry: AVE_pendie, A_Calzada, P_Ancho_Cl, A_separado, A_andenes, sum_carril;\nSignage and Markings: sen_horizo , se_hor_seg , sen_vert , semaforo, X1_girar_iz , X5policiasa , X6pare , X7estaciona , X8zonas_esc , X9ceder_el;\nTraffic Flow and Patterns: segme_via, velcidad, sent_vial;\nPedestrian Infrastructure: Puente_PT, A_andenes, peatonale\nCycling Infrastructure: largo_cicl, X2_ciclov.;\nPublic Transportation: Rutas_TRM, Rutas_SITP, Parad_SITP, Caril_SITP, X3bus_o_Tra;\nLandscaping: arboles.\n\n\n\nCode\nroad_geo &lt;- c(\"AVE_pendie\", \"A_Calzada\", \"P_Ancho_Cl\",\n  \"A_separado\", \"A_andenes\",\"sum_carril\") \n#not including \"av_carrile\"\n\nsign1 &lt;- c(\"sen_horizo\",\"se_hor_seg\",\"sen_vert\", \"semaforo\")\nsign2 &lt;- c(\"X1_girar_iz\", \"X5policiasa\", \"X6pare\", \n  \"X7estaciona\", \"X8zonas_esc\", \"X9ceder_el\")\n\nflow &lt;- c(\"segme_via\", \"velcidad\", \"sent_vial\")\n\nped &lt;- c(\"A_andenes\", \"X4peatonale\")\n\nbike &lt;- c(\"largo_cicl\",\"X2_ciclov.\")\n\ntransit &lt;- c(\"Rutas_TRM\",\"Rutas_SITP\", \"Parad_SITP\",  \n  \"Caril_SITP\",\"X3bus_o_Tra\")\n\nlandsc &lt;- c(\"arboles\")\n\n\nBelow are the distribution of the variables in each domain:\n\nRoad Geometry\n\n\nCode\ncalle_clean_df %&gt;% \n  select(CodigoCL, all_of(road_geo)) %&gt;%\n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\")+\n  theme_minimal()+\n  facet_wrap(~variables, scales = \"free\")+\n  labs(title = \"Distribution of Street-level Road Geometry Features\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nSignage and Markings\n\n\nCode\ncalle_clean_df %&gt;% \n  select(CodigoCL, all_of(sign1)) %&gt;%\n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\")+\n  theme_minimal()+\n  facet_wrap(~variables, scales = \"free\")+\n  labs(title = \"Distribution of Street-level Signage Features\",\n    subtitle = \"Part 1\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\nCode\ncalle_clean_df %&gt;% \n  select(CodigoCL, all_of(sign2)) %&gt;%\n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\")+\n  theme_minimal()+\n  facet_wrap(~variables, scales = \"free\")+\n  labs(title = \"Distribution of Street-level Signage Features\",\n    subtitle = \"Part 2\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nTraffic Flow and Patterns\n\n\nCode\ncalle_clean_df %&gt;% \n  select(CodigoCL, all_of(flow)) %&gt;%\n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\", binwidth = 1)+\n  theme_minimal()+\n  facet_wrap(~variables, scales = \"free\")+\n  labs(title = \"Distribution of Street-level Features on Traffic Flow\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nPedestrian and Cycling Infrastructure\n\n\nCode\ncalle_clean_df %&gt;% \n  select(CodigoCL, all_of(ped), all_of(bike)) %&gt;%\n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\")+\n  theme_minimal()+\n  facet_wrap(~variables, scales = \"free\")+\n  labs(title = \"Distribution of Street-level Pedestrian and Cycling Features\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 12),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 15, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\nLandscaping\n\n\nCode\ncalle_clean_df %&gt;% \n  select(CodigoCL, all_of(landsc)) %&gt;%\n  pivot_longer(-CodigoCL, names_to = \"variables\") %&gt;% \n  ggplot(aes(x=value)) +\n  geom_histogram(fill = \"skyblue\", color = \"blue\")+\n  theme_minimal()+\n  facet_wrap(~variables, scales = \"free\")+\n  labs(title = \"Distribution of ST-level Landscaping Features\")+\n  theme(\n    strip.background = element_rect(fill = \"#dadada\", color = \"white\"),\n    strip.text = element_text(size = 11),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 12, face = \"bold\", hjust = 0))"
  },
  {
    "objectID": "posts/Calles_var/calles_var.html#multicorrelation-between-variables",
    "href": "posts/Calles_var/calles_var.html#multicorrelation-between-variables",
    "title": "Street Level Variables",
    "section": "Multicorrelation between Variables",
    "text": "Multicorrelation between Variables\n\n\nCode\ncor_mx &lt;- calle_clean_df %&gt;% \n  select(-CodigoCL, -area, -Puente_PT, -puente_vh) %&gt;% \n  cor(.)\n\ncor_mx[lower.tri(cor_mx, diag = TRUE)] &lt;- NA"
  },
  {
    "objectID": "posts/canvas_all_compare/canvas_all_compare.html",
    "href": "posts/canvas_all_compare/canvas_all_compare.html",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "",
    "text": "As another post to document the process of the (preliminary) assessments of the reliability of the AI model for built environment (BE) features, here, we are comparing the training data for the AI model, model-based predictions and GIS data against Computer Assisted Neighborhood Visual Assessment System (CANVAS) data, which is considered a gold standard for BE data collection.\nThe code related to this post is stored in canvas_all_comparison.R, and linked here.\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(readr)\nlibrary(reactable)\nlibrary(leaflet)"
  },
  {
    "objectID": "posts/canvas_all_compare/canvas_all_compare.html#canvas---gis-data",
    "href": "posts/canvas_all_compare/canvas_all_compare.html#canvas---gis-data",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "1. CANVAS - GIS data",
    "text": "1. CANVAS - GIS data\n\nData cleaning\n\nCANVAS data\nRaw data file is located at Data/Bogota/CANVAS/Bogota_AllRaters_20230519.csv. The format and variable names are different from training/prediction data, and the geometry of the data is street segments (lines).\nThere are 382 streets with valid inputs (1 street all NAs), and some of the streets are annotated by multiple raters. The reason we are using “AllRaters” file instead of the “MeanValues” file is because some of the variables contain numbers representing categories that need to be evaluated separately.\nBased on the manual for CANVAS annotation, we are selecting the relevant variables to compare with the GIS data, including veg_tree, str_med, str_tcont, str_tcont, str_tcont, str_scont, str_cwalk, str_blane, str_mod, swalk_pres, trans_blane.\nFor details regarding the canvas variables and their range, please see canvas_variables.xlsx in annotation_compare_hx/ folder.\n\n\nJoin CANVAS with GIS\nSince the CANVAS data is in street segments, we’ll join the line geometry to the street polygons where there are largest overlapping. Below shows the map of the street segments from CANVAS (blue) and the street that each segment is assigned to (purple).\n\n\n\n\n\n\nAfter joining to street level, we follow the same procedure to rename and derive the columns:\n\nPrefix “can_” for CANVAS data, prefix “gis_” for GIS data.\nSuffix “_yn” for binary variables.\n\nThe total street count is 350.\n\n\n\nReliability Metrics\n\n\n\n\nReliability metrics comparing GIS data vs CANVAS data\n\n\n\n\n\nROC curves of GIS vs CANVAS data\n\n\nThere are fewer variable pairs, because not all the features are available in CANVAS data. Among these comparisons, traffic lights, sidewalks, bike lanes, medians, trees and transit lanes show better agreement between GIS and CANVAS data."
  },
  {
    "objectID": "posts/canvas_all_compare/canvas_all_compare.html#canvas---training-data",
    "href": "posts/canvas_all_compare/canvas_all_compare.html#canvas---training-data",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "2. CANVAS - Training data",
    "text": "2. CANVAS - Training data\n\nData cleaning\nHere, we use the training data aggregated to street level to join with CANVAS data by street IDs (CodigoCL). We only end up with 69 streets, but we’ll still check the agreement between these two data sources. We’ll use the prefix “tr_” for training data, prefix “can_” for CANVAS data, and suffix “_yn” for binary columns.\n\n\nReliability Metrics\n\n\n\n\nReliability metrics comparing Training data vs CANVAS data\n\n\n\n\n\nROC curves of training vs CANVAS data\n\n\nSome of these metrics turned out a bit surprising, perhaps due to the small number of streets and street segments not completely positioning in the street polygons. But many features (7 out of 10) show fair to substantial agreement between training and CANVAS data, including traffic lights, crosswalks, bike lanes, transit lanes, speed bumps and trees."
  },
  {
    "objectID": "posts/canvas_all_compare/canvas_all_compare.html#canvas---prediction-data",
    "href": "posts/canvas_all_compare/canvas_all_compare.html#canvas---prediction-data",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "3. CANVAS - Prediction data",
    "text": "3. CANVAS - Prediction data\n\nData cleaning\nSimilarly, we are joining the prediction and CANVAS data by the street IDs after they are aggregated/matched to street level. The resulting street count is 85, and we’re using prefix “an_” for prediction data, prefix “can_” for CANVAS data, and suffix “_yn” for derived binary columns.\n\n\nReliability Metrics\n\n\n\n\nReliability metrics comparing Prediction data vs CANVAS data\n\n\n\n\n\nROC curves of prediction vs CANVAS data\n\n\n8 out of 10 features included here show fair to moderate agreement between prediction and CANVAS data, including traffic lights, school signs, sidewalks, bike lanes, transit lanes, medians, speed bumps and trees.\nIn summary, despite a smaller street number and fewer variable pairs for comparison, several features show reasonable agreement across GIS, training and prediction data when compared against CANVAS data, including traffic lights, sidewalks, bike lanes, medians, trees and transit lanes.\nInterestingly, training and prediction data have better agreement with CANVAS data than GIS data, with almost all of them showing kappa estimate &gt; 0.2. The variables with inconsistent agreement between training and prediction data (crosswalks, school signs, sidewalks) may have to do with the street/point location, whereas stop signs are the only features that don’t seem to align well between CANVAS and other sources."
  },
  {
    "objectID": "posts/EDA1_1st_look_var/EDA1_1st_look_var.html",
    "href": "posts/EDA1_1st_look_var/EDA1_1st_look_var.html",
    "title": "Initial Look into BEPIDL Data",
    "section": "",
    "text": "In this report, my goal is to get familiar with the variables (indicators), what they represent (according to codebook), how complete the datasets are, and potentially examine the distribution of the variables."
  },
  {
    "objectID": "posts/EDA1_1st_look_var/EDA1_1st_look_var.html#zat-level",
    "href": "posts/EDA1_1st_look_var/EDA1_1st_look_var.html#zat-level",
    "title": "Initial Look into BEPIDL Data",
    "section": "ZAT level",
    "text": "ZAT level\nAt ZAT level, two files (folders) are included (along with the codebook).\n\nZAT.zip: boundary files – a table of 1141 rows, 6 cols (each row being a ZAT unit);\nIntersections/ZAT_INDICADORES.xlsx: a table of 919 rows, 18 cols (each row being a ZAT unit).\n\n\nZAT folder\nTo begin with, I looked at the ZAT folder, which contains shapefiles that define boundaries of each ZAT zone.\n\n\nCode\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(reactable)\nlibrary(crosstalk)\n\nzat &lt;- st_read(\"../../../../data/ZAT/ZAT_geo/ZAT.shp\")\n\n\nReading layer `ZAT' from data source \n  `D:\\LocalGitHub\\BEPIDL\\data\\ZAT\\ZAT_geo\\ZAT.shp' using driver `ESRI Shapefile'\nSimple feature collection with 1141 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY, XYZ\nBounding box:  xmin: -74.88439 ymin: 3.70344 xmax: -73.05211 ymax: 5.83076\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  MAGNA-SIRGAS\n\n\nCode\nzat\n\n\nSimple feature collection with 1141 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY, XYZ\nBounding box:  xmin: -74.88439 ymin: 3.70344 xmax: -73.05211 ymax: 5.83076\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  MAGNA-SIRGAS\nFirst 10 features:\n         Area MUNCod NOMMun ZAT UTAM                       geometry\n1  1366816039      0   &lt;NA&gt; 810  N/A MULTIPOLYGON Z (((-74.08207...\n2   824419773      0   &lt;NA&gt; 809  N/A MULTIPOLYGON Z (((-74.05947...\n3  1823077343      0   &lt;NA&gt; 823  N/A MULTIPOLYGON Z (((-73.64757...\n4   929997085      0   &lt;NA&gt; 822  N/A MULTIPOLYGON Z (((-73.54534...\n5  1409253432      0   &lt;NA&gt; 821  N/A MULTIPOLYGON Z (((-73.59517...\n6  1085719093  11001 Bogotá 796 UPR3 MULTIPOLYGON Z (((-74.08374...\n7  1820638886      0   &lt;NA&gt; 800  N/A MULTIPOLYGON Z (((-74.30147...\n8  1503956580      0   &lt;NA&gt; 811  N/A MULTIPOLYGON Z (((-74.49689...\n9  2349669218      0   &lt;NA&gt; 820  N/A MULTIPOLYGON Z (((-73.99614...\n10 1322014504      0   &lt;NA&gt; 812  N/A MULTIPOLYGON Z (((-74.4526 ...\n\n\nCode\nzat %&gt;%\n  st_zm() %&gt;% \n  leaflet() %&gt;%\n  addTiles() %&gt;%\n  leaflet::addPolygons()\n\n\n\n\n\n\n\n\nZAT_INDICADORES\nNext, we’re looking at the ZAT_INDICADORES.xlsx table. From referencing the codebook, I noticed the indicators in this table seem to be the “old” version. For all the ZAT included, there are no missing data, while some of the values are zeros. Here we are showing the distribution of all the indicators in the table, grouped into three categories (loosely tentatively): features about public transit, road and traffic lights.\n\nPublic transit\n\n\nCode\nzat_data &lt;- read_xlsx(\"../../../../data/ZAT/ZAT_INDICADORES.xlsx\")\n\nzat_data_long &lt;- zat_data %&gt;% \n  select(-2, -3) %&gt;% \n  pivot_longer(-ZAT, names_to = \"indicator\")\n\nbus &lt;- c('BUSTOPDENS', 'NUMRBP', 'LONGRBP', 'NUMRT', 'LONGRT')\nonroad &lt;- c('LONGMV', 'LRDENS', 'BPRDRATE', 'NUMINT', 'INTDENS')\ntlight &lt;- c('NUMTTFLIGH', 'NUMPTFLIGH')\nbyroad &lt;- c('NUMTTREES', 'NUMSTTREES', 'NUMBRIDGES')\n  \nzat_data_long %&gt;% \n  filter(indicator%in%all_of(bus)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\")+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal() +\n  labs(title = \"Distribution of Indicators related to Bus/BRT\")\n\n\n\n\n\n\n\n\n\n\n\nRoad features\n\n\nCode\nzat_data_long %&gt;% \n  filter(indicator%in%all_of(onroad)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\")+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal()+\n  labs(title = \"Distribution of Indicators related to Features on the Road\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nzat_data_long %&gt;% \n  filter(indicator%in%all_of(byroad)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\", alpha = 0.7)+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal()+\n  labs(title = \"Distribution of Indicators related to Features by the Road\")\n\n\n\n\n\n\n\n\n\n\n\nTraffic lights\n\n\nCode\nzat_data_long %&gt;% \n  filter(indicator%in%all_of(tlight)) %&gt;% \n  ggplot(aes(x=value)) +\n           geom_histogram(fill = \"skyblue\", color = \"blue\", alpha = 0.7)+\n           facet_wrap(~indicator, scales = \"free\") +\n           theme_minimal()+\n  labs(title = \"Distribution of Indicators about Traffic Lights\")"
  },
  {
    "objectID": "posts/EDA1_1st_look_var/EDA1_1st_look_var.html#street-level",
    "href": "posts/EDA1_1st_look_var/EDA1_1st_look_var.html#street-level",
    "title": "Initial Look into BEPIDL Data",
    "section": "Street level",
    "text": "Street level\nSo far, the data folder included is:\n\nCalles_datos/\n\nThis is a geo-referenced data table containing qualitative and quantitative data at the street level. Due to the size of the table, we are taking first 100 rows to take a look at the geometry:\n\n\nCode\ncalles_100 &lt;- readRDS(\"../../../../clean_data/calles/calles_100.rds\")\n\ncalles_100 %&gt;% \n  leaflet() %&gt;% \n  addTiles() %&gt;% \n  leaflet::addPolygons()\n\n\n\n\n\n\nApart from the geometry information, there are many variables included in the table, and the variable names do not seem to be in codebook. Skimming the full table:\n\n\nCode\nskim_calles &lt;- read_csv(\"../../../../clean_data/calles/skim_calles.csv\") %&gt;% \n  select(-1) %&gt;% \n  rename(col_type = skim_type,\n         col_names = skim_variable) %&gt;% \n  relocate(col_names)\n         \ncalles &lt;- SharedData$new(skim_calles)\n\nreactable(calles,\n  columns = list(\n      col_names = colDef(\n        sticky = \"left\",\n      # Add a right border style to visually distinguish the sticky column\n        style = list(borderRight = \"1px solid #eee\"),\n        headerStyle = list(borderRight = \"1px solid #eee\")\n    )),\n  theme = reactableTheme(color = \"#002b36\"),\n    defaultColDef = colDef(minWidth = 150),\n    defaultPageSize = 12,\n    striped = TRUE,\n    highlight = TRUE,\n    bordered = TRUE,\n    resizable = TRUE) \n\n\n\n\n\n\nIn the initial skimming report above, the types of all 67 columns, mean/sd and distribution (for numeric columns) are shown. While the completion rate of the columns seem high, some of the columns have many zeros, with 75% percentile =0."
  },
  {
    "objectID": "posts/gis_all_compare/gis_all_compare.html",
    "href": "posts/gis_all_compare/gis_all_compare.html",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "",
    "text": "This post is to document the process of the (preliminary) assessments of the reliability of the AI model for built environment (BE) features, by comparing different data sources of BE features at the street level. Here, we are testing the reliability of training data for the AI model, model-based predictions and annotators’ reports, using GIS data or as reference; In another post, we are also testing the GIS/training/prediction/reports data against Computer Assisted Neighborhood Visual Assessment System (CANVAS) data, which is considered a gold standard for BE data collection.\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(readr)\nlibrary(reactable)"
  },
  {
    "objectID": "posts/gis_all_compare/gis_all_compare.html#gis---training-data",
    "href": "posts/gis_all_compare/gis_all_compare.html#gis---training-data",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "1. GIS - Training data",
    "text": "1. GIS - Training data\nThe code related to this part (and the next part) of the work is stored in train_predict_gis_comparison.R, and linked here. Alex has a Stata code for GIS-prediction comparison (discussed in the next section), and the R scripts here are following a similar workflow and naming fashion.\n\nData cleaning\n\n- Training data\nRaw data file is located at Data/Bogota/Annotations/2024_02_12/annotations.csv. Using the latitude and longitude columns, we can construct the coordinates and join that to the street (calle) level (point to polygons, with st_within). On a side note, there are 343 unmatched data points that are outside of the calle polygons (shown below).\n\nAfter spatially joining the training data to the street level, we can group by the street ID (CodigoCL) and sum up the counts for each street. For distinguishing variables about similar features between sources, we are adding “tr_” to all the variables from training data.\n\n\n- GIS data\nThe raw data for GIS data is the Calle_datos/ shapefiles, or the STREET_LEVEL.xlsx with updated column names (that match the codebook).\nMost of the cleaning is renaming the columns for easier understanding (following the styles by Alex’s Stata code), with an additional prefix of “gis_”.\n\n\n- Join and Derive\nLast, we are joining the training and GIS data by street IDs, and generate binary variables based on street-level counts (1 if counts &gt;0, 0 if otherwise). Most of the binary columns will have a suffix of “_yn”, with the following exceptions (these are also binary variables): gis_sw, gis_bike_lane, gis_any_bus and gis_median. Notably, some binary variables may be used to derive additional binary variables. For example, tr_pedxwalk_yn is set as 1 if either tr_sign_crossing_yn or tr_crosswalk_yn is 1.\nTotal street count is 8132.\n\n\n\nReliability Metrics\nGiven that locations of data points vary from different sources, the aggregated street-level counts may not be compatible for comparison. Here we are only comparing the binary variables of equivalent/similar features, including traffic signs, traffic lights, crosswalk, stop signs, yield signs, school zone signs, sidewalks, bike lanes, bus lanes, medians, speed bumps, trees, bus stops, parked vehicles, parking lanes, and BRT stations. For quick reference, below shows the summary table of the reliability metrics, and the ROC curves.\n\n\n\n\nReliability metrics comparing training data vs GIS data\n\n\n\n\n\nROC curves of training vs GIS data\n\n\nOverall, traffic lights, medians, sidewalks, trees, bus and BRT stops seem to have higher agreement between training and GIS data."
  },
  {
    "objectID": "posts/gis_all_compare/gis_all_compare.html#gis---prediction-data",
    "href": "posts/gis_all_compare/gis_all_compare.html#gis---prediction-data",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "2. GIS - Prediction data",
    "text": "2. GIS - Prediction data\nThe code related to this part (and the previous part) of the work is stored in train_predict_gis_comparison.R, and linked here.\n\nData cleaning\nAlex completed joining the prediction and GIS data (with SES level and road types) at the street level (Data/Bogota/Annotations/2024_02_12/predictions_st_mv.dbf), so we’ll use that to perform further processing:\n\nrename the columns: prefix “an_” for prediction data, prefix “gis_” for GIS data.\nderive the binary columns.\n\nWith NAs removed in street id, total street count is 7332.\n\n\nReliability Metrics\n\n\n\n\nReliability metrics comparing prediction data vs GIS data\n\n\n\n\n\nROC curves of prediction vs GIS data\n\n\nTraffic lights, sidewalks, median, trees, bus and BRT stops remain to have relatively high agreement between prediction and GIS data. In addition, bike lanes also showed much higher agreement in prediction-GIS comparison than training-GIS comparison."
  },
  {
    "objectID": "posts/gis_all_compare/gis_all_compare.html#spatial-overlap-between-training-and-prediction",
    "href": "posts/gis_all_compare/gis_all_compare.html#spatial-overlap-between-training-and-prediction",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "*Spatial Overlap between Training and Prediction",
    "text": "*Spatial Overlap between Training and Prediction\nIn the image below, prediction data is shown in orange, while training data is shown in blue. The slightly darker shade of blue indicates the streets that are present in both training and prediction data aggregated to street level (~1000 streets)."
  },
  {
    "objectID": "posts/gis_all_compare/gis_all_compare.html#gis---annotators",
    "href": "posts/gis_all_compare/gis_all_compare.html#gis---annotators",
    "title": "Diagnostic Evaluation of an AI Model for Built Environment Features",
    "section": "3. GIS - Annotators",
    "text": "3. GIS - Annotators\nThe code related to this part of the work is stored in annotator_gis_comparison.R, and linked here.\n\nData cleaning\nThese are another set of data from human annotators stored in .json format (in Bogota/Annotations/Annotations_2023_04_23/ folder). Each json contains a list of lists/tables (as shown below for test.json), and the more important and relevant information for us are the coordinates in the image file names (in red rectangle), the categories of the annotation (orange underlined: IDs and names) and the actual annotations. We’ll match the category name to the annotations by category id, match the image coordinates to the annotations by image id, combine the three json files (test.json, train.json and eval.json) together, and use the coordinates to join the point data to street level.\n\nLast, we’ll join GIS data by street IDs and rename/derive the columns.\n\nRename: prefix “js_” for annotators’ report, “gis_” for GIS data.\nBinary variables.\n\nTotal street count is 9178.\n\n\nReliability Metrics\n\n\n\n\nReliability metrics comparing annotation data vs GIS data\n\n\n\n\n\nROC curves of annotators’ vs GIS data\n\n\nConsistently, traffic lights, sidewalks, medians, bike lanes, trees, bus and BRT stops show better agreement between annotators’ data and GIS data.\nIn summary, compared with GIS data, several features have fair to substantial agreement across training, prediction and annotators’ data, including traffic lights, sidewalks, medians, trees and bus and BRT stops (potentially bike lanes)."
  },
  {
    "objectID": "posts/traffic_sign/traffic_sign.html",
    "href": "posts/traffic_sign/traffic_sign.html",
    "title": "Traffic Sign Data Cleaning",
    "section": "",
    "text": "update\n\n\n\nCheck out the updated shiny dashboard of ZAT-level indicators!\nIn this post, the goal is to clean the traffic sign raw data and count individual types of signs at the street level.\nCode\nlibrary(dplyr)\nlibrary(sf)\nlibrary(stringr)\nlibrary(leaflet)\nlibrary(glue)\nlibrary(reactable)\nlibrary(crosstalk)"
  },
  {
    "objectID": "posts/traffic_sign/traffic_sign.html#data-preparation",
    "href": "posts/traffic_sign/traffic_sign.html#data-preparation",
    "title": "Traffic Sign Data Cleaning",
    "section": "Data Preparation",
    "text": "Data Preparation\n\nImport\nRaw data is UNI_ANDES 2/Punto 4/Inventario.gdb, a geodatabase with multiple layers, and from the layer “SEN_VERTICAL” we can find each type of traffic signs with their status and coordinates (with geometry being points). For example, the first ten rows of the raw data looks like this (last column SHAPE is for geometries):\n\n\nCode\nraw &lt;- st_read(\"../data/traffic_sign/Inventario.gdb/\", layer = \"SEN_VERTICAL\")\n\n\n\n\n\n\n\n\nIn the column names:\nTIPO_SENAL is the type of signs. FASE refers to its current state. ACCION refers to what needs to happen to the sign. FECHA_FASE is the date of that state. ESTADO is the condition of the sign. \nFASE categories:\n\nImplementación = they need to be installed\nProgramación = they need to schedule the action \nInventario = part of the existing inventory, no action\n\nACCION categories:\n\nInstalación - installation (not sure if it means to be I stalled or was installed on the date)\nRetirar - remove\nInventario - no action\nReemplazar - replace \nMantenimiento- maintenance \n\nESTADO:\n\nBueno - good\nRegular - fair\nMalo - poor\n\n\n\nCleaning and grouping\nSince we need to group the traffic sign data to the street level, we’ll perform a spatial join to identify which street (polygon) each sign (point) is in (no point unassigned). Next, we’re removing the rows with missing TIPO_SENAL to clean the data, and grouping the data by type of traffic signs and their status (FASE and ACCION) to count a street-level sum.\n\n\nCode\ncalle &lt;- st_read(\"../data/Calles/Calles_datos/Calles_datos.shp\")\n\nsign_st &lt;- calle %&gt;% \n  select(CodigoCL, geometry) %&gt;% \n  st_transform(crs = st_crs(raw)) %&gt;% \n  st_join(raw, left = TRUE, join = st_contains) %&gt;% \n  as.data.frame()\n\nclean_sign &lt;- sign_st %&gt;% \n  select(-geometry) %&gt;% \n  drop_na(TIPO_SENAL) %&gt;% \n  group_by(CodigoCL, TIPO_SENAL, FASE, ACCION) %&gt;% \n  summarise(n = n(), .groups = \"drop\") \n\n\nFor pedestrian crossing sign, we’re including SP-46, SI-24 and SR-19. For parking sign, we’re including SI-07. The resulting tables with each type of traffic signs and their status are stored in pedx_calle.csv and parking_calle.csv.\n\n\nCode\n# ped crossing: SP-46, SI-24, SR-19 ---------------------------------\npedx &lt;- clean_sign %&gt;% \n  filter(str_detect(TIPO_SENAL, pattern = \"SP-46|SI-24|SR-19\")) \n  #ungroup()\n\nwrite_csv(pedx, file = \"../../../../clean_data/pedx_calle.csv\")\n\n# parking: SI-07, SI-07A -----------------------------------------------\nparking &lt;- clean_sign %&gt;% \n  filter(str_detect(TIPO_SENAL, pattern = \"SI-07\"))\n\nwrite_csv(parking, file = \"../../../../clean_data/parking_calle.csv\")"
  },
  {
    "objectID": "posts/traffic_sign/traffic_sign.html#spatial-visualization",
    "href": "posts/traffic_sign/traffic_sign.html#spatial-visualization",
    "title": "Traffic Sign Data Cleaning",
    "section": "Spatial Visualization",
    "text": "Spatial Visualization\nFor exploratory purposes, we’ll plot the pedestrian crossing signs and parking signs on the map, without taking into consideration the status of the signs.\n\nPedestrian Crossing\n\n\nCode\npedx_pa_geo_sm &lt;- readRDS(\"../../../../clean_data/traffic_sign/pedx_pa_geo_sm.rds\")\n\npedx &lt;- pedx_pa_geo_sm %&gt;% \n  filter(str_detect(sign, \"SP46|SI24|SR19\"))\n\npal &lt;- colorNumeric(\n  palette = \"plasma\",\n  domain = pedx$n\n)\n\nzat_label &lt;- glue(\"CodigoCL{pedx$CodigoCL} Traffic sign {pedx$sign} count: {pedx$n}\")\n\npedx %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal(n),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal,\n            values = ~n,\n            title = \"Pedestrian Crossing Sign &lt;br/&gt; (Street-level)\",\n            opacity = 1)\n\n\n\n\n\n\nIn total there are 4536 streets that have pedestrian crossing signs in Bogotá. Pedestrian crossing signs are present throughout many neighborhoods, despite the often small number of crossing signs per street.\n\n\nParking\n\n\nCode\nparking &lt;- pedx_pa_geo_sm %&gt;% \n  filter(str_detect(sign, pattern = \"SI07\"))\n\npal2 &lt;- colorNumeric(\n  palette = \"plasma\",\n  domain = parking$n\n)\n\nzat_label2 &lt;- glue(\"CodigoCL{parking$CodigoCL} Traffic sign {parking$sign} count: {parking$n}\")\n\nparking %&gt;% \n  st_zm() %&gt;%\n  st_transform(crs = st_crs(\"+proj=longlat +datum=WGS84\")) %&gt;%\n  leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Voyager)  %&gt;%\n  addPolygons(color = \"white\", \n              weight = 0.5,\n              smoothFactor = 0.5,\n              opacity = 1,\n              fillColor = ~pal2(n),\n              fillOpacity = 0.8,\n              highlightOptions = highlightOptions(\n                weight = 5,\n                color = \"#666\",\n                fillOpacity = 0.8,\n                bringToFront = TRUE),\n              label = zat_label2,\n              labelOptions = labelOptions(\n                style = list(\n                  \"font-family\" = \"Fira Sans, sans-serif\",\n                  \"font-size\" = \"1.2em\"\n                ))\n              )%&gt;% \n  addLegend(\"bottomleft\",\n            pal = pal2,\n            values = ~n,\n            title = \"Parking Sign &lt;/br&gt; (Street-level)\",\n            opacity = 1)\n\n\n\n\n\n\nIn total there are 524 streets that have parking signs in Bogotá, and they seem to have the highest density near the area “Localidad Chapinero”."
  },
  {
    "objectID": "posts/ZAT_profile/ZAT_profile.html",
    "href": "posts/ZAT_profile/ZAT_profile.html",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "",
    "text": "After visualizing ZAT-level variable distributions spatially on maps and statistically through histograms, we’ll now try using finite mixture modeling to fit our data to understand the neighborhood profiles.\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(tibble)\nlibrary(flexmix)\nlibrary(ggbeeswarm)\nlibrary(reactable)\nlibrary(crosstalk)"
  },
  {
    "objectID": "posts/ZAT_profile/ZAT_profile.html#data-preparation",
    "href": "posts/ZAT_profile/ZAT_profile.html#data-preparation",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Data preparation",
    "text": "Data preparation\nIn the previous post, we used the raw data to explore the variable distributions. To get the data ready for modeling, we’ll need to clean and standardize the data.\nThe cleaning step is straightforward, where we leave out the ZAT units with zero road network length (LRDENS, in meters) and/or intersections. 4 ZAT units don’t have measurable road network length or intersections, and another 9 ZAT units don’t have intersections, which reduce the dataset from 919 rows (ZAT units) to 906 rows.\nTo standardize the data, we’re using areakm2 to normalize the countinuous and count data that have not already been area-adjusted (eg., NUMRBP, NUMTTFLIGH, NUMSTTREES), and taking a natural log of the length measurements in meters (eg., LRDENS, LONGRBP), with the bike lane rate transformed into log length of bike lanes.\n\n\nCode\nzat_std &lt;- zat_raw_data %&gt;%\n  filter(LRDENS &gt; 0, \n         NUMINT &gt;0) %&gt;% \n  mutate(\n    road_length_log = log(LRDENS),\n    st_4ln_length_log = log(LONGMV),\n    bikelane_per_km2 = BPRDRATE * LRDENS,\n    bikelane_m_log = case_when(bikelane_per_km2 &gt; 0 ~ log(bikelane_per_km2),\n                              .default = bikelane_per_km2),\n    sttree_per_km2 = NUMSTTREES / areakm2,\n    bridg_per_km2 = NUMBRIDGES / areakm2,\n    trlight_per_km2 = NUMTTFLIGH / areakm2,\n    numrbp_per_km2 = NUMRBP/areakm2,\n    numrt_per_km2 = NUMRT/areakm2,\n    longrbp_per_km2 = LONGRBP / areakm2,\n    longrt_per_km2 = LONGRT / areakm2,\n    bus_length_log = case_when(longrbp_per_km2 &gt; 0 ~ log(longrbp_per_km2),\n                               .default = longrbp_per_km2),\n    brt_length_log = case_when(longrt_per_km2 &gt; 0 ~ log(longrt_per_km2),\n                               .default = longrt_per_km2)\n  ) \n\n\nThe histograms of the distribution of the original variables, standardized variables and their mean/variance can be viewed on this interactive shiny dashboard. For downstream modeling, we’ll only include the standardized variables.\n\n\nCode\nzat_std2 &lt;- zat_std %&gt;% \n  select(ZAT, BUSTOPDENS, road_length_log, st_4ln_length_log, bikelane_m_log, \n         sttree_per_km2, bridg_per_km2, trlight_per_km2, numrbp_per_km2,\n         numrt_per_km2, bus_length_log, brt_length_log)"
  },
  {
    "objectID": "posts/ZAT_profile/ZAT_profile.html#correlation-among-variables",
    "href": "posts/ZAT_profile/ZAT_profile.html#correlation-among-variables",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Correlation among variables",
    "text": "Correlation among variables\nFirst we’ll explore the correlation among these variables.\n\n\nCode\nzat_cor &lt;- zat_std2 %&gt;% select(-ZAT) %&gt;% cor()\n\nzat_cor[lower.tri(zat_cor, diag = FALSE)] &lt;- NA\n# &gt;0.6 related variables\n\ncor_react &lt;- zat_cor %&gt;% as.data.frame() %&gt;% \n  rownames_to_column(var = \"var\")\n\ncor_react2 &lt;- SharedData$new(cor_react)\n\nreactable(cor_react2, \n    columns = list(\n      var = colDef(\n        sticky = \"left\",\n      # Add a right border style to visually distinguish the sticky column\n        style = list(borderRight = \"1px solid #eee\"),\n        headerStyle = list(borderRight = \"1px solid #eee\")\n    )),\n  theme = reactableTheme(color = \"#002b36\"),\n    defaultColDef = colDef(minWidth = 150),\n    defaultPageSize = 11,\n    striped = TRUE,\n    highlight = TRUE,\n    bordered = TRUE,\n    resizable = TRUE\n  )\n\n\n\n\n\n\nThe variables that show strong correlation are:\n\n\nCode\nas.data.frame(zat_cor) %&gt;%\n  rownames_to_column(\"var1\") %&gt;% \n  pivot_longer(cols = -var1, names_to = \"var2\", values_to = \"cor\") %&gt;% \n  filter(cor &gt;0.6 & cor != 1) %&gt;% \n  print()\n\n\n# A tibble: 3 × 3\n  var1            var2                cor\n  &lt;chr&gt;           &lt;chr&gt;             &lt;dbl&gt;\n1 road_length_log st_4ln_length_log 0.617\n2 road_length_log bus_length_log    0.635\n3 numrt_per_km2   brt_length_log    0.661\n\n\nThe length of toad network is shown to be correlated with both the length of streets with 4 or more lanes and the length of bus routes. Although the number of BRT routes are expectedly correlated with the length of the BRT routes, that’s not the case for bus routes. Based on this, we’ll exclude road_length_log and numrt_per_km2 in our modeling."
  },
  {
    "objectID": "posts/ZAT_profile/ZAT_profile.html#model-based-clustering",
    "href": "posts/ZAT_profile/ZAT_profile.html#model-based-clustering",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Model-based clustering",
    "text": "Model-based clustering\nSince the clean and standardized data are all continuous data, despite some of them being zero-inflated, it would still be reasonable to choose a Gaussian model for clustering. We’ll also make an attempt to categorize the variables into two domains and fit the model for each domain and both domains together.\n\nStreet design domain: st_4ln_length_log, bikelane_m_log, trlight_per_km2, sttree_per_km2, bridg_per_km2;\nTransportation domain: BUSTOPDENS, bus_length_log, brt_length_log, numrbp_per_km2.\n\n\n\nCode\nzat_fmm &lt;- zat_std2 %&gt;% select(-road_length_log, -numrt_per_km2)\n\nstreet &lt;- zat_fmm %&gt;% \n  select(st_4ln_length_log, bikelane_m_log, trlight_per_km2, sttree_per_km2, bridg_per_km2) %&gt;% \n  colnames()\n\ntransportation &lt;- zat_fmm %&gt;% \n  select(BUSTOPDENS, bus_length_log, brt_length_log, numrbp_per_km2) %&gt;% \n  colnames()\n\nall &lt;- zat_fmm %&gt;% \n  select(-ZAT) %&gt;% \n  colnames()\n\n\nUsing the flexmix R package, we’ll fit the model using a range of component numbers, from 1 to 7, and use Bayesian Information Criteria (BIC) values to select the optimal number of clusters (usually at smallest BIC value or when the BIC decrease &lt; 1.5%). For example, the BIC values for all variables (both domains) look like this with k (component number) going from 1 to 7 (in this case k=3 is selected as the optimal number of clusters):\n\n\nCode\n#normal\nsource(\"../../../../functions/fmm_normal.R\")\n\nstreet_mix&lt;- fmm_normal(zat_fmm, street, 1:7)\ntransp_mix &lt;- fmm_normal(zat_fmm,transportation, 1:7)\nall_mix &lt;- fmm_normal(zat_fmm, all, 1:7)\n\nsource(\"../../../../functions/elbow_bic.R\")\nelbow_bic(all_mix, 1:7, title = \"Elbow Plot for BIC Values (all variables)\")\n\n\n\nNote that the modeling result and their BIC values could vary each time we run the stepFlexmix(), because the Expectation-Maximization (EM) algorithm involves random initialization of parameters."
  },
  {
    "objectID": "posts/ZAT_profile/ZAT_profile.html#neighborhood-profiles",
    "href": "posts/ZAT_profile/ZAT_profile.html#neighborhood-profiles",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Neighborhood profiles",
    "text": "Neighborhood profiles\nAfter determining the cluster numbers, we could visualize the ZAT-level built environment profiles across different variables.\n\n\nCode\n#beeswarm\nsource(\"../../../../functions/plot_profile.R\")\nplot_profile(zat_fmm, street_mix, street, title = \"Neighborhood Profiles: Street Desgin\")\nplot_profile(zat_fmm, transp_mix, transportation, title = \"Neighborhood Profiles: Transportation\")\nplot_profile(zat_fmm, all_mix, all, title = \"Neighborhood Profiles: All Indicators\")\n\n\n\nStreet design domain:\n\n\n\nTransportation domain:\n\n\n\nAll variables:"
  },
  {
    "objectID": "posts/ZAT_profile/ZAT_profile.html#posterior-probabilities",
    "href": "posts/ZAT_profile/ZAT_profile.html#posterior-probabilities",
    "title": "Neighborhood Built Environment Profiles in Bogotá",
    "section": "Posterior probabilities",
    "text": "Posterior probabilities\nFrom the fitted models, we can also extract the posterior probabilities of cluster assignment for each ZAT unit. For example, in the model where all the variables are included, the posterior probabilities for each ZAT unit can be visualized in the plot below:\n\n\nCode\nmix_best &lt;- getModel(all_mix, \"BIC\")\n\npost_p &lt;- posterior(mix_best) %&gt;% as.data.frame() %&gt;% \n  rownames_to_column(var = \"ZAT\") %&gt;% \n  mutate(order = V1-V3) %&gt;% \n  pivot_longer(c(V1, V2, V3), names_to = \"cluster\", values_to = \"prob\")\n\nggplot(post_p, aes(x = reorder(ZAT, order), y = prob, fill = cluster)) +\n  geom_bar(stat = \"identity\", position = \"fill\", width = 1) +  # Adjust the width to fill the space\n  scale_fill_brewer(palette = \"YlGnBu\") +\n  coord_flip() +  # Rotate the plot to make it look like a heatmap\n  scale_x_discrete(expand = c(0, 0)) +  # Remove space between groups\n  labs(x = \"ZAT Units\", y = \"Posterior Probabilities\", title = \"Posterior Probabilities of Cluster Assignment of Each ZAT Unit\") +\n  theme(axis.text.y = element_blank(),\n        axis.line.y = element_blank(),\n        title = element_text(face = \"bold\", size = 13),\n        axis.title.x = element_text(size = 12),\n        axis.text = element_text(size = 10),\n        legend.text = element_text(size = 10))"
  }
]